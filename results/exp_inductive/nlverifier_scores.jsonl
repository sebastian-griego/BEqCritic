{"problem_id": "Munkres|exercise_13_4b1", "nl_statement": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$.", "candidates": ["theorem dummy {X : Type*} {Œπ : Type*} [TopologicalSpace X] (t : Œπ ‚Üí TopologicalSpace X) : ‚àÉ (T : TopologicalSpace X), ‚àÄ (Œ± : Œπ), T ‚â§ t Œ± := sorry", "theorem dummy {X : Type*} {I : Sort*} {T : I ‚Üí TopologicalSpace X} : ‚àÉ (t : TopologicalSpace X), ‚àÄ i, t ‚â§ T i ‚àß ‚àÄ s, (‚àÄ i, s ‚â§ T i) ‚Üí s ‚â§ t := sorry", "theorem dummy {Œ± : Type _} {f : Œ± ‚Üí TopologicalSpace X} : (‚àÄ a b : Œ±, ‚àÉ c : Œ±, f c ‚â§ f a ‚äì f b) ‚Üí ‚àÉ! ùíØ : TopologicalSpace X, ‚àÄ a : Œ±, ùíØ ‚â§ f a := sorry", "theorem dummy (X : Type u) [TopologicalSpace X] (Œπ : Type v) (t : Œπ ‚Üí TopologicalSpace X): ‚àÉ T : TopologicalSpace X, ‚àÄ i : Œπ, T ‚â§ t i := sorry", "theorem dummy {X : Type*} {Œπ : Type u} [TopologicalSpace X] (t : Œπ ‚Üí TopologicalSpace X) : ‚àÉ (t' : TopologicalSpace X), ‚àÄ (i : Œπ), t' ‚â§ t i := sorry", "theorem dummy {X : Type*} (Œπ : Type*) (t : Œπ ‚Üí TopologicalSpace X) : ‚àÉ! T : TopologicalSpace X, ‚àÄ (Œ± : Œπ), T ‚â§ t Œ± := sorry", "theorem dummy {X : Type*} (T : Œπ ‚Üí Set (Set X)) : ‚àÉ! (T_min : TopologicalSpace X), ‚àÄ Œ±, ‚àÄ U ‚àà T Œ±, @IsOpen X T_min U := sorry", "theorem dummy {X : Type*} {Œπ : Type*} {T : Œπ ‚Üí Filter X} : ‚àÉ (S : Filter X), (‚àÄ Œ±, T Œ± ‚â§ S) ‚àß ‚àÄ (S' : Filter X), (‚àÄ Œ±, T Œ± ‚â§ S') ‚Üí S ‚â§ S' := sorry", "theorem dummy {X : Type*} (T : Œπ ‚Üí Set (Set X)) : ‚àÉ! t : TopologicalSpace X, ‚àÄ Œ±, ‚àÄ s ‚àà T Œ±, t.IsOpen s := sorry", "theorem dummy {X : Type*} (T : Œπ ‚Üí Set (Set X)) : ‚àÉ! t : TopologicalSpace X, ‚àÄ Œ±, ‚àÄ s ‚àà T Œ±, t.IsOpen s ‚àß ‚àÄ t', (‚àÄ Œ±, ‚àÄ s ‚àà T Œ±, t'.IsOpen s) ‚Üí t ‚â§ t' := sorry", "theorem dummy (X : Type*) [TopologicalSpace X] (Top : ‚Ñï ‚Üí Set (Set X)) (h : ‚àÄ n, Top n = {U : Set X | IsOpen U}) (hne : ‚àÄ (U : Set X), U ‚àà Top 0 ‚Üí U ‚â† ‚àÖ) : ‚àÉ N : ‚Ñï, ‚àÄ (n : ‚Ñï), N ‚â§ n ‚Üí Top n = Top N := sorry", "theorem dummy {X : Type*} (Œπ : Type*) (T : Œπ ‚Üí TopologicalSpace X) : ‚àÉ t : TopologicalSpace X, ‚àÄ i, T i ‚â§ t ‚àß ‚àÄ t', ‚àÄ i, T i ‚â§ t' ‚Üí t ‚â§ t' := sorry", "theorem dummy { X : Type*} {Œ± : Type*} (Ta : Œ± ‚Üí Set (Set X)) : ‚àÉ (T : Set (Set X)), (‚àÄ (Œ± : Œ±), T ‚äá Ta Œ±) ‚àß (‚àÄ (S : Set (Set X)), (‚àÄ (Œ± : Œ±), S ‚äá Ta Œ±) ‚Üí S ‚äá T) := sorry", "theorem dummy (t : Œπ ‚Üí Set (Set X)) : (generateFrom (‚ãÉ Œ±, t Œ±) : TopologicalSpace X) ‚â§ s ‚Üî (‚àÄ Œ±, generateFrom (t Œ±) ‚â§ s) := sorry", "theorem dummy {X : Type u} {Œπ : Sort v} {t : Œπ ‚Üí TopologicalSpace X} : TopologicalSpace.generateFrom (‚ãÉ i, (t i).IsOpen) = ‚®Ö i, t i := sorry", "theorem dummy (X : Type*) (T : Œ± ‚Üí TopologicalSpace X) : ‚àÉ (S : TopologicalSpace X), ‚àÄ (i : Œ±), T i ‚â§ S ‚àß ‚àÄ (S' : TopologicalSpace X), (‚àÄ (i : Œ±), T i ‚â§ S') ‚Üí S ‚â§ S' := sorry", "theorem dummy (t : Œπ ‚Üí Topology X) : sInf t = sInf { t } := sorry", "theorem dummy (Œ± : Type v) [Encodable v] {X : Type u} (T : Œ± ‚Üí TopologicalSpace X) : ‚àÉ! t : TopologicalSpace X, ‚àÄ a : Œ±, T a ‚â§ t := sorry", "theorem dummy {X : Type*} (T : Œπ ‚Üí TopologicalSpace X) : ‚àÉ! (T‚ÇÄ : TopologicalSpace X), (‚àÄ i, T i ‚â§ T‚ÇÄ) ‚àß ‚àÄ (T' : TopologicalSpace X), (‚àÄ i, T i ‚â§ T') ‚Üí T‚ÇÄ ‚â§ T' := sorry", "theorem dummy (Œ± : Type u) (X : Type u) (T : Œπ ‚Üí TopologicalSpace X) : ‚àÉ! t : TopologicalSpace X, (‚àÄ i, t ‚â§ T i) := sorry", "theorem dummy {X : Type*} (T : ‚àÄ Œ± : Type*, Set (Set X)) : ‚àÉ! t : TopologicalSpace X, ‚àÄ Œ±, ‚àÄ s ‚àà T Œ±, @TopologicalSpace.IsOpen X t s := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-6.089746952056885, -6.101930618286133, -6.1295576095581055, -6.123208999633789, -6.108006000518799, -6.105532169342041, -0.5680500268936157, -6.083431243896484, -5.11601448059082, -5.6060380935668945, -5.953509330749512, -6.11393404006958, -5.910477638244629, -4.719780921936035, -5.722476482391357, -6.09031867980957, -6.079172134399414, -6.15734338760376, -6.141653537750244, -6.090346336364746, -5.216513633728027], "chosen_index": 6}
{"problem_id": "Shakarchi|exercise_1_13c", "nl_statement": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.", "candidates": ["theorem dummy (f : ‚ÑÇ ‚Üí ‚ÑÇ) {s : Set ‚ÑÇ} (hs : IsOpen s) (hf : AnalyticOn ‚ÑÇ f s) : (‚àÄ z ‚àà s, abs (f z) = c) ‚Üí (‚àÄ z ‚àà s, f z = c) := sorry", "theorem dummy {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] {f : E ‚Üí ‚ÑÇ} {s : Set E} (hf : AnalyticOn ‚ÑÇ f s) (h : BddAbove (norm ‚àò f '' s)) : ‚àÉ (c : ‚ÑÇ), ‚àÄ (z : E), z ‚àà s ‚Üí f z = c := sorry", "theorem dummy {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] {s : Set E} {f : E ‚Üí ‚ÑÇ} (hf : ‚àÄ z ‚àà s, HasFDerivAt f (0 : E ‚ÜíL[‚ÑÇ] ‚ÑÇ) z) (h : ‚àÄ z ‚àà s, f z = Complex.abs (f z)) : ‚àÄ z ‚àà s, f z = (0 : ‚ÑÇ) := sorry", "theorem dummy {f : ‚ÑÇ ‚Üí ‚ÑÇ} {s : Set ‚ÑÇ} (hf : AnalyticOn ‚ÑÇ f s) (h : ‚àÄ z ‚àà s, abs (f z) = c) : ‚àÉ c : ‚ÑÇ, ‚àÄ z ‚àà s, f z = c := sorry", "theorem dummy {Œ© : Set ‚ÑÇ} (hŒ© : IsOpen Œ©) {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ‚àÄ z ‚àà Œ©, DifferentiableAt ‚ÑÇ f z) (h_const : ‚àÉ c : ‚Ñù, ‚àÄ z ‚àà Œ©, abs (f z) = c) : ‚àÉ c : ‚ÑÇ, ‚àÄ z ‚àà Œ©, f z = c := sorry", "theorem dummy {f : ‚ÑÇ ‚Üí ‚ÑÇ} {s : Set ‚ÑÇ} (hf : AnalyticOn ‚ÑÇ f s) (hc : ‚àÄ z ‚àà s, abs (f z) = c) (hs : IsOpen s) : ‚àÄ z ‚àà s, f z = c := sorry", "theorem dummy (hf : IsHolomorphicOn f Œ©) (h : IsConst (abs ‚àò f)) : IsConst f := sorry", "theorem dummy {X : Type u} [NormedAddCommGroup X] [NormedSpace ‚ÑÇ X] {f : ‚ÑÇ ‚Üí X} (hf : AnalyticAt ‚ÑÇ f 0) (h : ‚àÄ z : ‚ÑÇ, z ‚àà Metric.ball 0 1 ‚Üí ‚Äñf z‚Äñ = 1) : ‚àÉ c, f = const ‚ÑÇ c := sorry", "theorem dummy (hf : HolomorphicIn ‚ÑÇ l f) (h : IsConstant <| abs ‚àò f) : IsConstant f := sorry", "theorem dummy {f : ‚ÑÇ ‚Üí ‚ÑÇ} {s : Set ‚ÑÇ} (hf : AnalyticOn ‚ÑÇ f s) (habs : ‚àÄ z ‚àà s, abs (f z) = 0) : AnalyticOn ‚ÑÇ f s ‚àß f = 0 := sorry"], "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], "scores": [-6.095340728759766, -6.1479339599609375, -5.989204406738281, -6.043617248535156, 2.988386869430542, -5.505292892456055, -4.651586532592773, -5.716707706451416, -5.2554931640625, -6.093740463256836], "chosen_index": 4}
{"problem_id": "Rudin|exercise_3_22", "nl_statement": "Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.", "candidates": ["theorem dummy {X : Type u} [MetricSpace X] (hX : Nonempty X) [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (hG‚ÇÅ : ‚àÄ n, Dense (G n)) (hG‚ÇÇ : ‚àÄ n, IsOpen (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy [Nonempty X] {G : ‚Ñï ‚Üí Set X} (hG : ‚àÄ n, IsOpen (G n)) (hG' : ‚àÄ n, Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type _} [Nonempty X] [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (hG : ‚àÄ n, Dense (G n)) (hG' : ‚àÄ n, IsOpen (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X] (G : ‚Ñï ‚Üí Set X) (hG_open : ‚àÄ n, IsOpen (G n)) (hG_dense : ‚àÄ n, Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type _} [MetricSpace X] [Inhabited X] (hX : CompleteSpace X) (G : ‚Ñï ‚Üí Set X) (hG_open : ‚àÄ (n : ‚Ñï), IsOpen (G n)) (hG_dense : ‚àÄ (n : ‚Ñï), Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X] {G : ‚Ñï ‚Üí Set X} (hG : ‚àÄ n, IsOpen (G n) ‚àß Dense (G n)) : ‚àÉ x : X, ‚àÄ n : ‚Ñï, x ‚àà G n := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (ho : ‚àÄ n, IsOpen (G n)) (hd : ‚àÄ n, Dense (G n)) : (‚ãÇ (n : ‚Ñï), G n).Nonempty := sorry", "theorem dummy {X : Type*} [Nonempty X] [MetricSpace X] (G : ‚Ñï ‚Üí Set X) (hG : ‚àÄ n, Dense (G n) ‚àß IsOpen (G n)) : (‚ãÇ (n : ‚Ñï), G n).Nonempty := sorry", "theorem dummy {X : Type*} [Nonempty X] [MetricSpace X] {G : ‚Ñï ‚Üí Set X} (hG‚ÇÅ : ‚àÄ n, Dense (G n)) (hG‚ÇÇ : ‚àÄ n, IsOpen (G n)) : (‚ãÇ (n : ‚Ñï), G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [Nonempty X] {n : ‚Ñï} {G : ‚Ñï ‚Üí Set X} (hG_open : ‚àÄ n, IsOpen (G n)) (hG_dense : ‚àÄ n, Dense (G n)) (hG_nonempty : ‚àÄ n, Set.Nonempty (G n)) : Set.Nonempty (‚ãÇ i, G i) := sorry", "theorem dummy (X : Type*) [Nonempty X] [MetricSpace X] [CompleteSpace X] {G : ‚Ñï ‚Üí Set X} (hG : ‚àÄ n, Dense (G n)) (hG_open : ‚àÄ n, IsOpen (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [Nonempty X] [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (hG‚ÇÅ : ‚àÄ n, IsOpen (G n)) (hG‚ÇÇ : ‚àÄ n, Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] {G : ‚Ñï ‚Üí Set X} (hG : ‚àÄ n, IsOpen (G n)) (hG_dense : ‚àÄ x : X, ‚àÉ n, x ‚àà G n) : ‚àÉ x : X, ‚àÄ n, x ‚àà G n := sorry", "theorem dummy {X : Type*} [MetricSpace X] [Inhabited X] (hX : CompleteSpace X) (G : ‚Ñï ‚Üí Set X) (hG‚ÇÅ : ‚àÄ n, IsOpen (G n)) (hG‚ÇÇ : ‚àÄ n, Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [Nonempty X] [MetricSpace X] (G : ‚Ñï ‚Üí Set X) (hG : ‚àÄ n, IsOpen (G n)) (hGd : ‚àÄ n, Dense (G n)) : ¬¨(‚àÄ n : ‚Ñï, IsEmpty (G n)) := sorry", "theorem dummy {X : Type*} [MetricSpace X] [Nonempty X] (hX : CompleteSpace X) (G : ‚Ñï ‚Üí Set X) (h‚ÇÅ : ‚àÄ n, IsOpen (G n)) (h‚ÇÇ : ‚àÄ n, Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (hG_open : ‚àÄ n, IsOpen (G n)) (hG_dense : ‚àÄ n, Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X] (G : ‚Ñï ‚Üí Set X) (hg : ‚àÄ n, IsOpen (G n) ‚àß Dense (G n)) : ‚àÉ x : X, ‚àÄ n, x ‚àà G n := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X] {G : ‚Ñï ‚Üí Set X} (hG : ‚àÄ n, IsOpen (G n)) (hd : ‚àÄ x : X, ‚àÉ n, x ‚àà G n) : Nonempty (‚ãÇ (n : ‚Ñï), G n) := sorry", "theorem dummy {X : Type*} [Nonempty X] [MetricSpace X] [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (hG1 : ‚àÄ n, Dense (G n)) (hG2 : ‚àÄ n, IsOpen (G n)) : (‚ãÇ (n : ‚Ñï), G n).Nonempty := sorry", "theorem dummy {X : Type _} [NormedAddCommGroup X] [NormedSpace ‚Ñù X] [CompleteSpace X] (G : ‚Ñï ‚Üí Set X) (hG : ‚àÄ n, IsOpen (G n)) (hG' : ‚àÄ n, Dense (G n)) : Dense (‚ãÇ n, G n) := sorry", "theorem dummy (X : Type*) [MetricSpace X] [Nonempty X] (hX : CompleteSpace X) (n : ‚Ñï) (G : ‚Ñï ‚Üí Set X) (hG : ‚àÄ i, IsOpen (G i)) (hG' : ‚àÄ i, Dense (G i)) : (‚ãÇ i, G i).Nonempty := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X] (G : ‚Ñï ‚Üí Set X) (hG : ‚àÄ n, IsOpen (G n) ‚àß Dense (G n)) : (‚ãÇ n, G n).Nonempty := sorry"], "labels": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1], "scores": [0.9622383117675781, -5.175007343292236, -3.2694344520568848, 6.742037773132324, 2.376688241958618, 5.872775077819824, -0.21215689182281494, -3.0167689323425293, -4.73576545715332, -4.163166046142578, 7.00208854675293, 1.7943413257598877, 6.1294145584106445, -0.09041216969490051, -3.2891061305999756, 3.3303823471069336, 6.436479568481445, 7.51262092590332, -2.5978002548217773, 3.5171737670898438, -5.703557968139648, 5.101309776306152, 6.782716751098633], "chosen_index": 17}
{"problem_id": "Putnam|exercise_2000_a2", "nl_statement": "Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.", "candidates": ["theorem dummy (n : ‚Ñï) : ‚àÉ m : ‚Ñï, m > n ‚àß ‚àÉ (a b c : ‚Ñï), m = a ^ 2 + b ^ 2 ‚àß m + 1 = a ^ 2 + c ^ 2 ‚àß m + 2 = b ^ 2 + c ^ 2 := sorry", "theorem dummy (n : ‚Ñï) : ‚àÉ (k : ‚Ñï), k ‚â• n ‚àß ‚àÉ (a b c : ‚Ñ§), a ^ 2 + b ^ 2 = k ‚àß a ^ 2 + c ^ 2 = k + 1 ‚àß b ^ 2 + c ^ 2 = k + 2 := sorry", "theorem dummy (n : ‚Ñï) : ‚àÉ m : ‚Ñï, m ‚â• n ‚àß ‚àÉ (a b c : ‚Ñï), m = a ^ 2 + b ^ 2 ‚àß m + 1 = c ^ 2 + (c + 1) ^ 2 ‚àß m + 2 = (c + 1) ^ 2 + (c + 2) ^ 2 := sorry", "theorem dummy : ‚àÉ·∂† n in atTop, ‚àÉ a b c d : ‚Ñ§, a ^ 2 + b ^ 2 = c ^ 2 + d ^ 2 := sorry", "theorem dummy : ‚àÉ·∂† n in at_top, (‚àÉ a b : ‚Ñ§, n = a^2 + b^2) ‚àß (‚àÉ c d : ‚Ñ§, n+1 = c^2 + d^2) ‚àß (‚àÉ e f : ‚Ñ§, n+2 = e^2 + f^2) := sorry", "theorem dummy : ‚àÉ (n : ‚Ñï) (m : ‚Ñï), n^2 + (n+1)^2 = m^2 ‚àß (n+2)^2 = m^2 := sorry", "theorem dummy {n : ‚Ñï} (hn : 0 < n) : ‚àÉ (a b c : ‚Ñ§), (a^2 + b^2 = n ‚àß b^2 + c^2 = n+1 ‚àß c^2 + a^2 = n+2) ‚à® (b^2 + a^2 = n+1 ‚àß a^2 + c^2 = n ‚àß c^2 + b^2 = n+2) ‚à® (c^2 + b^2 = n+2 ‚àß b^2 + a^2 = n+1 ‚àß a^2 + c^2 = n) := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (i j : ‚Ñ§), i * i + j * j = n ‚àß i * i + (j + 1) * (j + 1) = n + 1 ‚àß i * i + (j + 2) * (j + 2) = n + 2 := sorry", "theorem dummy : ‚àÉ n : ‚Ñ§, ‚àÄ m : ‚Ñ§, ‚àÉ p : ‚Ñ§, ‚àÉ q : ‚Ñ§, ((n:‚Ñù) ^ 2 + (p:‚Ñù) ^ 2 = (m ^ 2 + q ^ 2 : ‚Ñù)) := sorry", "theorem dummy (n : ‚Ñï) : ‚àÉ m ‚â• n, ‚àÉ k l, m = k ^ 2 + l ^ 2 ‚àß m + 1 = k ^ 2 + l ^ 2 ‚àß m + 2 = k ^ 2 + l ^ 2 := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (k : ‚Ñï), ‚àÄ (i : ‚Ñï), ‚àÉ (a b : ‚Ñ§), a ^ 2 + b ^ 2 = k ‚àß a ^ 2 + b ^ 2 = n + i ‚àß a ^ 2 + b ^ 2 = (n + i) + 1 := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (n : ‚Ñï), ‚àÉ (m : ‚Ñï), ‚àÉ (k : ‚Ñï), n = m^2 + k^2 ‚àß (n+1) = (m+1)^2 + k^2 ‚àß (n+2) = m^2 + (k+1)^2 := sorry", "theorem dummy : ‚àÉ·∂† n in atTop, ‚àÉ a b : ‚Ñ§, n = a ^ 2 + b ^ 2 ‚àß n + 1 = a ^ 2 + (b + 1) ^ 2 ‚àß n + 2 = a ^ 2 + (b + 2) ^ 2 := sorry", "theorem dummy : ‚àÉ n : ‚Ñï, ‚àÄ m : ‚Ñï, m ‚â• n ‚Üí ‚àÉ (x y z : ‚Ñï), x ^ 2 + y ^ 2 = m ‚àß z ^ 2 + (z + 1) ^ 2 = m + 1 ‚àß (z + 2) ^ 2 + (z + 3) ^ 2 = m + 2 := sorry", "theorem dummy : ‚àÉ·∂† n in at_top, (‚àÉ a b : ‚Ñ§, n = a^2 + b^2) ‚àß (‚àÉ c d : ‚Ñ§, n + 1 = c^2 + d^2) ‚àß (‚àÉ e f : ‚Ñ§, n + 2 = e^2 + f^2) := sorry", "theorem dummy (n : ‚Ñï) : ‚àÉ m : ‚Ñï, ‚àÉ a b c : ‚Ñ§, a^2 + b^2 = n ‚àß b^2 + c^2 = n+1 ‚àß c^2 + a^2 = n+2 := sorry", "theorem dummy : { n : ‚Ñ§ | ‚àÉ a b : ‚Ñ§, a ^ 2 + b ^ 2 = n ‚àß a ^ 2 + (b + 1) ^ 2 = n + 1 ‚àß a ^ 2 + (b + 2) ^ 2 = n + 2 }.Infinite := sorry", "theorem dummy (n : ‚Ñï) (hn : ‚àÄ k < n, k ‚â† n + 1 ‚Üí (k : ‚Ñ§) = (k : ‚Ñ§) ^ 2 + (k : ‚Ñ§) ^ 2) : ‚àÉ (m : ‚Ñï), (m : ‚Ñ§) = (m : ‚Ñ§) ^ 2 + (m : ‚Ñ§) ^ 2 ‚àß (m + 1 : ‚Ñ§) = (m + 1 : ‚Ñ§) ^ 2 + (m + 1 : ‚Ñ§) ^ 2 ‚àß (m + 2 : ‚Ñ§) = (m + 2 : ‚Ñ§) ^ 2 + (m + 2 : ‚Ñ§) ^ 2 := sorry", "theorem dummy (n : ‚Ñï) (hn : 0 < n) : ‚àÉ (m : ‚Ñï), 0 < m ‚àß ‚àÉ (k : ‚Ñï), 0 < k ‚àß n = m^2 + (m+1)^2 + (m+k)^2 := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (i j : ‚Ñ§), i^2 + j^2 = n ‚àß i^2 + (j+1)^2 = n+1 ‚àß (i+1)^2 + j^2 = n+2 := sorry", "theorem dummy : ‚àÉ·∂† n in atTop, ‚àÉ a b c d : ‚Ñ§, a ^ 2 + b ^ 2 = n ‚àß c ^ 2 + d ^ 2 = n + 1 := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (k : ‚Ñï), ‚àÉ (i j : ‚Ñ§), i^2 + j^2 = n ‚àß i^2 + (j+1)^2 = n+1 ‚àß (i+1)^2 + j^2 = n+2 := sorry", "theorem dummy : ‚àÉ·∂† n in at_top, ‚àÉ a b c d e f : ‚Ñ§, n = a^2 + b^2 ‚àß n + 1 = c^2 + d^2 ‚àß n + 2 = e^2 + f^2 := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (i j : ‚Ñ§), n = i * i + j * j ‚àß (n + 1 = i' * i' + j' * j') ‚àß (n + 2 = i'' * i'' + j'' * j'') := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (i j : ‚Ñ§), i ^ 2 + j ^ 2 = n ‚àß i ^ 2 + (j + 1) ^ 2 = n + 1 ‚àß (i + 1) ^ 2 + j ^ 2 = n + 2 := sorry", "theorem dummy : ‚àÉ·∂† n in atTop, ‚àÉ a b : ‚Ñ§, a * a + b * b = n ‚àß a * a + (b + 1) * (b + 1) = n + 1 ‚àß a * a + (b + 2) * (b + 2) = n + 2 := sorry", "theorem dummy : ‚àÉ·∂† n in at_top, ‚àÉ a b c d e f : ‚Ñ§, n = a^2 + b^2 ‚àß (n + 1) = c^2 + d^2 ‚àß (n + 2) = e^2 + f^2 := sorry", "theorem dummy {n : ‚Ñï} (hn : 1 ‚â§ n) : ‚àÉ a b c : ‚Ñ§, a ^ 2 + b ^ 2 = n ‚àß b ^ 2 + c ^ 2 = n + 1 ‚àß c ^ 2 + a ^ 2 = n + 2 := sorry", "theorem dummy (n : ‚Ñï) : ‚àÉ k : ‚Ñï, k ‚â• n ‚àß ‚àÉ x y : ‚Ñ§, k = x ^ 2 + y ^ 2 ‚àß (k + 1) = (x + 1) ^ 2 + y ^ 2 ‚àß (k + 2) = (x + 1) ^ 2 + (y + 1) ^ 2 := sorry", "theorem dummy : ‚àÉ·∂† n in atTop, ‚àÉ a b c d : ‚Ñ§, a ^ 2 + b ^ 2 = n ‚àß c ^ 2 + d ^ 2 = n + 1 ‚àß a ^ 2 + c ^ 2 = n + 2 := sorry", "theorem dummy {n : ‚Ñï} : ‚àÉ (i : ‚Ñï), ‚àÄ (j : ‚Ñï), (i + 1 ‚â§ j ‚àß j ‚â§ i + 3) ‚Üí ‚àÉ (m k : ‚Ñ§), m^2 + k^2 = n ‚àß m^2 + k^2 = n + 1 ‚àß m^2 + k^2 = n + 2 := sorry", "theorem dummy : ‚àÉ·∂† n in atTop, ‚àÉ a b c : ‚Ñ§, a * a + b * b = n ‚àß a * a + c * c = n + 1 ‚àß b * b + c * c = n + 2 := sorry", "theorem dummy : ‚àÉ S : Set ‚Ñï, S.Infinite ‚àß ‚àÄ n ‚àà S, (‚àÉ a b, n = a^2 + b^2) ‚àß (‚àÉ c d, (n + 1) = c^2 + d^2) ‚àß (‚àÉ e f, (n + 2) = e^2 + f^2) := sorry", "theorem dummy : Set.Infinite {n : ‚Ñï | ‚àÉ a b c : ‚Ñ§, n = a^2 + b^2 ‚àß n+1 = a^2 + c^2 ‚àß n+2 = b^2 + c^2} := sorry", "theorem dummy : ‚àÉ·∂† n in at_top, ‚àÉ a b c d e f : ‚Ñ§, n = a^2 + b^2 ‚àß n+1 = c^2 + d^2 ‚àß n+2 = e^2 + f^2 := sorry", "theorem dummy (n : ‚Ñï) : ‚àÉ m : ‚Ñï, m ‚â• Nat.succ (n + 1) ‚àß ‚àÉ (x y z : ‚Ñï), ‚àÉ (hx : IsSquare x), ‚àÉ (hy : IsSquare y), ‚àÉ (hz : IsSquare z), m = x + y + z := sorry"], "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0], "scores": [-6.056023120880127, -5.915097236633301, -6.047802925109863, -5.48735237121582, -3.3922412395477295, -5.986250400543213, -5.615294456481934, -5.993233680725098, -5.713268280029297, -5.8202385902404785, -5.828539848327637, -5.975124835968018, -5.856910705566406, -6.090633392333984, -3.3657069206237793, -5.889957427978516, -5.927076816558838, -6.127566814422607, -5.745304107666016, -5.961248397827148, -5.540506362915039, -5.988921165466309, 3.1528830528259277, -5.999963760375977, -6.118839263916016, -5.320006370544434, 5.63064432144165, -5.990024566650391, -6.0471625328063965, -5.738643169403076, -5.459666728973389, -5.301140785217285, 5.038477897644043, -5.604942321777344, 2.163257122039795, -3.897225856781006], "chosen_index": 26}
{"problem_id": "Herstein|exercise_2_6_15", "nl_statement": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.", "candidates": ["theorem dummy {G : Type _} [Group G] {m n : ‚Ñï} (hm : ‚àÄ g : G, g ^ m = 1) (hn : ‚àÄ g : G, g ^ n = 1) (hmn : m ‚à£ n ‚à® n ‚à£ m) : ‚àÉ g : G, g ^ m * g ^ n = 1 := sorry", "theorem dummy {G : Type*} [AddCommGroup G] (m n : ‚Ñï) [Fact (Nat.Prime m)] [Fact (Nat.Prime n)] (hm : ‚àÉ g, g ‚â† 0 ‚àß orderOf g = m) (hn : ‚àÉ g, g ‚â† 0 ‚àß orderOf g = n) : ‚àÉ g, g ‚â† 0 ‚àß orderOf g = m * n := sorry", "theorem dummy {G : Type _} [CancelCommMonoid G] (m n : ‚Ñï) (hG : ‚àÄ a : G, IsOfFinOrder a ‚Üí ‚àÄ p : ‚Ñï, p.Prime ‚Üí p ‚à£ orderOf a) (hmn : m * n ‚à£ orderOf a) (a_ne_one : a ‚â† 1) : ‚àÉ p : ‚Ñï, p.Prime ‚àß p ‚à£ m ‚àß p ‚à£ n := sorry", "theorem dummy (G : Type*) [CommGroup G] (m n : ‚Ñï) (hm : ‚àÄ x : G, x ^ m = 1 ‚Üí x = 1) (hn : ‚àÄ x : G, x ^ n = 1 ‚Üí x = 1) : ‚àÉ x : G, x ^ (m * n) = 1 ‚àß x ‚â† 1 := sorry", "theorem dummy {G : Type*} [CommGroup G] {m n : ‚Ñï} (hmn : Nat.Coprime m n) (hm : ‚àÉ x : G, orderOf x = m) (hn : ‚àÉ y : G, orderOf y = n) : ‚àÉ z : G, orderOf z = m * n := sorry", "theorem dummy {G : Type*} [Group G] [CommGroup G] (m n : ‚Ñï) (hm : ‚àÉ x, x ^ m = 1) (hn : ‚àÉ y, y ^ n = 1) (hmn : Nat.gcd m n = 1) : ‚àÉ z, z ^ (m * n) = 1 := sorry", "theorem dummy {G : Type _} [Group G] {m n : ‚Ñï} (hm : IsOfOrder G m) (hn : IsOfOrder G n) (cop : m.coprime n) : IsOfOrder G (m * n) := sorry", "theorem dummy [Group G] [CommGroup G] (m n : ‚Ñï) (hm : ‚àÉ x, x ^ m = 1) (hn : ‚àÉ y, y ^ n = 1) (hmn : gcd m n = 1) : ‚àÉ z, z ^ (m * n) = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] {m n : ‚Ñï} (hm : Fintype.card G = m) (hmn : Nat.gcd m n = 1) (h : ‚àÉ x : G, x ^ m = 1) (h' : ‚àÉ y : G, y ^ n = 1) : ‚àÉ z : G, z ^ (m * n) = 1 := sorry", "theorem dummy {G : Type*} [AddCommGroup G] [DecidableEq G] {a b : G} {m n : ‚Ñï} (ha : a ‚â† 0) (hma : (addOrderOf a : ‚Ñ§) = m) (hna : (addOrderOf b : ‚Ñ§) = n) (hmn : Int.gcd m n = 1) : ‚àÉ c : G, (addOrderOf c : ‚Ñ§) = m * n := sorry", "theorem dummy {G : Type*} [CommGroup G] {m n : ‚Ñï} (hm : ‚àÉ x, x ^ m = 1) (hn : ‚àÉ y, y ^ n = 1) (hmn : Nat.gcd m n = 1) : ‚àÉ z, z ^ (m * n) = 1 := sorry", "theorem dummy {G : Type*} [CommGroup G] {m n : ‚Ñï} {a b : G} (ha : a ^ m = 1) (hb : b ^ n = 1) : (a * b) ^ (m * n) = 1 ‚Üî (a * b) ^ (m * n) = 1 := sorry", "theorem dummy [IsAbelian G] {m n : ‚Ñï} (hm : Exists (orderOf G = m)) (hn : Exists (orderOf G = n)) (hmn : m.RatPrimes n) : Exists (orderOf G = m * n) := sorry", "theorem dummy {G : Type*} [Group G] [CommGroup G] (hm : ‚àÉ x : G, x ^ m = 1 ‚àß ‚àÄ y : G, y ^ n = 1 ‚Üí y = 1) (hn : ‚àÉ y : G, y ^ n = 1 ‚àß ‚àÄ x : G, x ^ m = 1 ‚Üí x = 1) (m n : ‚Ñï) (hmn : ¬¨ Nat.gcd m n = 0) : ‚àÉ z : G, z ^ (m * n) = 1 := sorry", "theorem dummy (G : Type*) [CommGroup G] {a b : G} (ha : a ‚â† 1) (hb : b ‚â† 1) (h : ¬¨IsCoprime (orderOf a) (orderOf b)) : ‚àÉ x : G, orderOf x = Nat.lcm (orderOf a) (orderOf b) := sorry"], "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-6.006313323974609, -4.205321311950684, -4.971463203430176, -5.916187763214111, 3.5198440551757812, -4.687670707702637, -5.885765075683594, -5.993370056152344, -4.692409038543701, -5.5562591552734375, -4.609954833984375, -4.979474067687988, -5.949012756347656, -5.872580528259277, -1.0044910907745361], "chosen_index": 4}
{"problem_id": "Munkres|exercise_38_6", "nl_statement": "Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-ƒåech compactification of $X$ is connected.", "candidates": ["theorem dummy [CompleteRegularSpace X] : IsConnected X ‚Üî IsConnected (stoneCech X) := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [T2Space X] [T3Space X] (hX : CompletelyRegularSpace X) : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [T3Space X] : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [T2Space X] [CompactSpace X] : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy (X : Compactum) : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy {X : Type u} [TopologicalSpace X] (hX : CompletelyRegularSpace X) : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy {X : Type u} [TopologicalSpace X] [CompactSpace X] [T2Space X] : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [CompletelyRegularSpace X] : ConnectedSpace X ‚Üî ConnectedSpace (StoneCech X) := sorry"], "labels": [0, 0, 0, 0, 0, 0, 1, 0, 1], "scores": [-2.363003969192505, 2.392192840576172, -4.0524492263793945, -4.808371543884277, -3.9334306716918945, -3.44357967376709, 3.773451328277588, -4.761539936065674, 3.9452993869781494], "chosen_index": 8}
{"problem_id": "Herstein|exercise_4_2_5", "nl_statement": "Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative.", "candidates": ["theorem dummy (R : Type u) [Ring R] (h : ‚àÄ x : R, x^3 = x) : ‚àÄ a b : R, a * b = b * a := sorry", "theorem dummy (R) [Ring R] [‚àÄ x : R, x ^ 3 = x] : IsCommutative R (¬∑ * ¬∑) := sorry", "theorem dummy {R : Type*} [Ring R] (h : ‚àÄ x : R, x^3 = x) : ‚àÄ x y : R, x*y = y*x := sorry", "theorem dummy (R : Type*) [Ring R] (h : ‚àÄ x : R, x^3 = x) : ‚àÄ x y : R, x * y = y * x := sorry", "theorem dummy [CommRing R] (h : ‚àÄ (x : R), x ^ 3 = x) : ‚àÄ x y : R, x * y = y * x := sorry", "theorem dummy (R : Type*) [CommRing R] (h : ‚àÄ x : R, x^3 = x) : ‚àÄ x y : R, x*y = y*x := sorry", "theorem dummy (h : ‚àÄ x : R, x ^ 3 = x) : IsCommutative R := sorry", "theorem dummy {R : Type*} [Ring R] (h : ‚àÄ x : R, x ^ 3 = x) : ‚àÄ a b : R, a * b = b * a := sorry", "theorem dummy {R : Type _} [Ring R] (hR : ‚àÄ x : R, x ^ 3 = x) {x : R} : x * x * x = x := sorry", "theorem dummy {R : Type u} [CommRing R] (h : ‚àÄ x : R, x ^ 3 = x) : ‚àÄ x y : R, x * y = y * x := sorry", "theorem dummy {R : Type*} [Ring R] (h : ‚àÄ x : R, x ^ 3 = x) : ‚àÄ x y : R, x * y = y * x := sorry", "theorem dummy (R : Type*) [Ring R] (x : R) : x^3 = x ‚Üí ‚àÄ x y : R, x*y = y*x := sorry", "theorem dummy (R : Type u) [Ring R] (h : ‚àÄ (x : R), x^3 = x) : ‚àÄ (x y : R), x*y = y*x := sorry", "theorem dummy (R : Type*) [Ring R] (h : ‚àÄ x : R, x ^ 3 = x) : ‚àÄ x y : R, x * y = y * x := sorry"], "labels": [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], "scores": [6.148550033569336, -2.408686637878418, 7.658243179321289, 7.888299942016602, -4.108545303344727, 1.5729972124099731, -4.695219993591309, 7.6575164794921875, -2.184234142303467, -1.9875504970550537, 7.837576866149902, -5.7135419845581055, 5.118592739105225, 7.807643890380859], "chosen_index": 3}
{"problem_id": "Herstein|exercise_4_3_25", "nl_statement": "Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.", "candidates": ["theorem dummy : I = (0) ‚à® I = R := sorry", "theorem dummy {R : Type*} [Ring R] (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (R : Type _) [CommRing R] [IsDomain R] [Algebra ‚Ñö R] (I : Ideal R) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type _} [Ring R] [Invertible (2 : R)] (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {a b c d : ‚Ñù} (I : Ideal (Matrix (Fin 2) (Fin 2) ‚Ñù)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy [Ring R] {I : Ideal R} (hI : I ‚â† ‚ä•) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type*} [CommRing R] (I : Ideal (Matrix (Fin 2) (Fin 2) ‚Ñù)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (R : Type _) [Ring R] (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : finrank R I = 0 ‚à® finrank R I = 2 := sorry", "theorem dummy {R : Type*} [Ring R] (I : Ideal R) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (M : Type*) [Ring M] [Invertible (2 : M)] (I : Ideal M) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (I : Ideal (Matrix (Fin 2) (Fin 2) ‚Ñù)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type*} [CommRing R] [DecidableEq R] [Fintype R] [DecidableEq R] (I : Ideal R) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type*} [Ring R] [Nontrivial R] (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type*} [CommRing R] [Ring R] (I : Ideal R) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type*} [CommRing R] [IsDomain R] : ‚àÄ (I : Ideal (Matrix (Fin 2) (Fin 2) R)), I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (R : Type*) [Ring R] (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {R : Type*} [CommRing R] [IsDomain R] (I : Ideal (Matrix (Fin 2) (Fin 2) R)) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy (R : Type*) [Ring R] (I : Ideal R) : I = ‚ä• ‚à® I = ‚ä§ := sorry", "theorem dummy {I : Ideal (Matrix (Fin 2) (Fin 2) ‚Ñù)} : I = ‚ä• ‚à® I = ‚ä§ := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], "scores": [-4.042285442352295, 0.40213754773139954, -5.926728248596191, 7.018539905548096, -3.382401943206787, -3.314642906188965, -5.438364028930664, -3.3922805786132812, -0.3854418396949768, 5.590183734893799, -5.7456464767456055, -6.051565170288086, 1.9554438591003418, -6.130622386932373, -0.8355618119239807, -6.0647101402282715, -1.1918704509735107, -0.19994524121284485, -2.801882266998291, -5.804291248321533, 3.770188093185425], "chosen_index": 3}
{"problem_id": "Axler|exercise_4_4", "nl_statement": "Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common.", "candidates": ["theorem dummy [Field ‚ÑÇ] {p : Polynomial ‚ÑÇ} (h : p.degree = m) : p.roots.toFinset.card = m ‚Üî (p.roots ‚à© p.derivative.roots) = ‚àÖ := sorry", "theorem dummy {p : Polynomial ‚ÑÇ} {m : ‚Ñï} (h : Polynomial.degree p = m) (hp : ‚àÉ (z : ‚ÑÇ), Polynomial.eval z p = 0) (hz : ‚àÉ (z : ‚ÑÇ), Polynomial.eval z (Polynomial.derivative p) = 0) : (‚àÉ! (z : ‚ÑÇ), Polynomial.eval z p = 0) ‚àß (‚àÉ! (z : ‚ÑÇ), Polynomial.eval z (Polynomial.derivative p) = 0) := sorry", "theorem dummy {p : P} (hp : p.degree = m) : (p.hasDistinctRoots ‚Üî p.roots ‚à© p.derivative.roots = ‚àÖ) := sorry", "theorem dummy {p : Polynomial ‚ÑÇ} (hp : p.degree = m) (h : ‚àÄ x : ‚ÑÇ, ¬¨ (p.eval x = 0 ‚àß p.derivative.eval x = 0)) : Multiset.card (roots p) = m := sorry", "theorem dummy {p : Polynomial ‚ÑÇ} (hp : p.natDegree = m) : (‚àÄ z : ‚ÑÇ, p.eval z = 0 ‚Üí ‚àÄ w : ‚ÑÇ, p.eval w = 0 ‚Üí z = w) ‚Üî ‚àÄ z : ‚ÑÇ, p.eval z = 0 ‚Üí p.derivative.eval z ‚â† 0 := sorry", "theorem dummy (p : Polynomial ‚ÑÇ) {n : ‚Ñï} (hp : p.natDegree = n) (hd : p.roots.toFinset ‚â† p.derivative.roots.toFinset) : ‚àÉ (s : Finset ‚ÑÇ) (H : s.card = n), ‚àÄ (x : ‚ÑÇ), x ‚àà s ‚Üí p.eval x = 0 ‚àß ‚àÄ (x : ‚ÑÇ), x ‚àà s ‚Üí p.derivative.eval x ‚â† 0 := sorry", "theorem dummy {p : Polynomial ‚ÑÇ} (hdeg : p.degree = p.roots.toFinset.card) : p.roots.toFinset ‚à© p.derivative.roots.toFinset = ‚àÖ := sorry", "theorem dummy {p : ‚ÑÇ[X]} (h : p.degree = m) : (‚àÄ x : ‚ÑÇ, p.eval x = 0 ‚Üí p.derivative.eval x = 0) ‚Üî ‚àÄ x : ‚ÑÇ, p.eval x = 0 ‚Üí x ‚â† 0 := sorry", "theorem dummy {p : Polynomial ‚ÑÇ} (hp : p.degree = m) : (‚àÄ z, ¬¨ p.IsRoot z) ‚Üî ‚àÄ z, ¬¨ p.derivative.IsRoot z := sorry"], "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-2.5054244995117188, -6.047330379486084, -4.458113670349121, -5.149125099182129, -5.9457244873046875, -5.885826110839844, -5.388095855712891, -6.091843605041504, -5.6556620597839355], "chosen_index": 0}
{"problem_id": "Rudin|exercise_1_13", "nl_statement": "If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$.", "candidates": ["theorem dummy (x y : ‚ÑÇ) : abs x - abs y ‚â§ abs (x - y) := sorry", "theorem dummy {x y : ‚ÑÇ} (h : x + y = 0) : abs x - abs y ‚â§ abs (x - y) := sorry", "theorem dummy (x y : ‚ÑÇ) : |x| - |y| ‚â§ |x - y| := sorry", "theorem dummy (x y : ‚ÑÇ) : abs (x - y) ‚â§ abs (x - y) := sorry", "theorem dummy (x y : ‚ÑÇ) : ‚Äñx‚Äñ - ‚Äñy‚Äñ ‚â§ ‚Äñx - y‚Äñ := sorry", "theorem dummy (x y : ‚ÑÇ) : abs (x - y) ‚â§ abs x - abs y := sorry", "theorem dummy {x y : ‚ÑÇ} : |abs x - abs y| ‚â§ abs (x - y) := sorry", "theorem dummy {K : Type*} [LinearOrderedField K] [OrderedAddCommGroup K] {x y : K} : abs (abs x - abs y) ‚â§ abs (x - y) := sorry", "theorem dummy (x y : ‚ÑÇ) : ||x|-|y|| ‚â§ |x - y| := sorry"], "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0], "scores": [-3.3373093605041504, -4.396786689758301, -5.093197822570801, -5.501036643981934, -4.93668270111084, -3.4685440063476562, 2.647953987121582, -3.739610195159912, -5.210635662078857], "chosen_index": 6}
{"problem_id": "Axler|exercise_7_10", "nl_statement": "Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.", "candidates": ["theorem dummy [InnerProductSpace ùïú V] {T : ùïú ‚ÜíL[ùïú] V} (hT : IsNormal T) (h : T ^ 9 = T ^ 8) : IsSelfAdjoint T ‚àß T ^ 2 = T := sorry", "theorem dummy {V : Type _} [InnerProductSpace ‚ÑÇ V] (T : V ‚Üí‚Çó[‚ÑÇ] V) (hT : IsNormal T) (h : T ^ 9 = T ^ 8) : IsSelfAdjoint T ‚àß T ^ 2 = T := sorry"], "labels": [0, 0], "scores": [7.803738594055176, 6.237908363342285], "chosen_index": 0}
{"problem_id": "Munkres|exercise_27_4", "nl_statement": "Show that a connected metric space having more than one point is uncountable.", "candidates": ["theorem dummy (X : Type*) [MetricSpace X] [DiscreteTopology X] [Nonempty X] [ConnectedSpace X] (h : 2 ‚â§ Cardinal.mk X) : Uncountable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] [Nonempty X] [ConnectedSpace X] : Uncountable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] [ConnectedSpace X] [Nonempty X] (h : ‚àÉ x y : X, x ‚â† y) : Uncountable X := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [MetricSpace X] [ConnectedSpace X] (hX : Nonempty X) (hX' : ‚àÉ x y : X, x ‚â† y) : Uncountable X := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [MetrizableSpace X] [ConnectedSpace X] (h : 2 ‚â§ 2 ^ aleph0) : 2 ^ aleph0 = 2 ^ Continuum := sorry", "theorem dummy : Uncountable (Œ±) := sorry", "theorem dummy {X : Type*} [MetricSpace X] [PreconnectedSpace X] [Nonempty X] [Nontrivial X] [Uncountable X] : Uncountable X := sorry", "theorem dummy : Uncountable (Œ± := Œ±) := sorry", "theorem dummy [M : MetricSpace Œ±] [hn : Nontrivial Œ±] (h : ‚àÉ x y : Œ±, Inseparable x y) : Uncountable Œ± := sorry", "theorem dummy [ConnectedSpace Œ±] [Nonempty Œ±] : Uncountable Œ± := sorry", "theorem dummy {X : Type*} [MetricSpace X] [ConnectedSpace X] (h_two_points : ‚àÉ x y : X, x ‚â† y) : Uncountable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] (hX : ConnectedSpace X) (hX1 : Nonempty X) : Uncountable X := sorry", "theorem dummy : ¬¨Uncountable Œ± := sorry", "theorem dummy {X : Type*} [MetricSpace X] [ConnectedSpace X] (h : ‚àÉ x y : X, x ‚â† y) : ¬¨ Countable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] [TopologicalSpace.SeparableSpace X] (hX : ConnectedSpace X) (h'X : ‚àÉ x y : X, x ‚â† y) : Uncountable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] [Nonempty X] (hX : ConnectedSpace X) : Uncountable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] (hX : ConnectedSpace X) (h : ‚àÉ x y : X, x ‚â† y) : ¬¨Countable X := sorry", "theorem dummy [Inhabited Œ±] [ConnectedSpace Œ±] (h2 : 2 ‚â§ Cardinal.mk Œ±) : Uncountable Œ± := sorry", "theorem dummy [Nonempty Œ±] [M : MetricSpace Œ±] [ConnectedSpace Œ±] (h : ¬¨Uncountable Œ±) : False := sorry", "theorem dummy {X : Type*} [MetricSpace X] [TopologicalSpace X] [ConnectedSpace X] (hX : Nonempty X) (hX' : Fintype X ‚Üí False) : Uncountable X := sorry", "theorem dummy {X : Type*} [MetricSpace X] [ConnectedSpace X] (h : ‚àÉ x y : X, x ‚â† y) : ¬¨Countable X := sorry"], "labels": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], "scores": [-4.356833457946777, -2.8149654865264893, 7.604928016662598, 6.096412181854248, -5.646139144897461, -4.669829368591309, -5.69211483001709, -4.60001277923584, -3.690095901489258, -4.4523844718933105, 8.028066635131836, -3.4158101081848145, -4.696794509887695, 7.931118488311768, 3.607834815979004, -3.676076889038086, 7.681156158447266, -4.527647972106934, -3.0094168186187744, -5.493167877197266, 7.9217376708984375], "chosen_index": 10}
{"problem_id": "Rudin|exercise_4_2a", "nl_statement": "If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).", "candidates": ["theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type _} [TopologicalSpace X] [TopologicalSpace Y] {f : X ‚Üí Y} (hf : Continuous f) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {f : X ‚Üí Y} (h : Continuous f) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (hf : Continuous f) {E : Set X} : closure (f '' E) ‚äÜ f '' closure E := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (h : Continuous f) (E : Set X) : closure (f '' E) ‚äÜ f '' (closure E) := sorry", "theorem dummy {X Y : Type _} [MetricSpace X] [MetricSpace Y] (f : C(X, Y)) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy (X Y : Type*) [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} {E : Set X} (hf : Continuous f) : closure (f '' E) ‚äÜ f '' closure E := sorry", "theorem dummy (f : C(X, Y)) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X} [TopologicalSpace X] {Y} [TopologicalSpace Y] {f : X ‚Üí Y} (h : Continuous f) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (hf : Continuous f) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (hf : Continuous f) (E : Set X) : closure (f '' E) ‚äÜ f '' (closure E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X ‚Üí Y} (hf : Continuous f) (E : Set X) : f '' (closure E) ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type _} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (hf : Continuous f) (E : Set X) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] {E : Set X} {f : X ‚Üí Y} (hf : Continuous f) : f '' closure E ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (hf : Continuous f) (E : Set X) : f '' (closure E) ‚äÜ closure (f '' E) := sorry", "theorem dummy {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) (hcont : Continuous f) (E : Set X) : closure (f '' E) ‚äÜ f '' (closure E) := sorry"], "labels": [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0], "scores": [6.36059045791626, -4.07875919342041, -0.6205422878265381, -3.9463534355163574, -4.56248664855957, 5.542336940765381, -4.297734260559082, -1.976223349571228, -4.797010898590088, 6.390815734863281, -4.289436340332031, 6.274752140045166, 4.806232452392578, 6.061661243438721, 6.351041793823242, -4.622930526733398], "chosen_index": 9}
{"problem_id": "Pugh|exercise_2_29", "nl_statement": "Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$.", "candidates": ["theorem dummy (M : Type*) [MetricSpace M] : ‚àÉ (f : Set M ‚Üí Set M), (‚àÄ U ‚àà {U : Set M | IsOpen U}, f U ‚àà {K : Set M | IsClosed K}) ‚àß (‚àÄ K ‚àà {K : Set M | IsClosed K}, ‚àÉ U ‚àà {U : Set M | IsOpen U}, f U = K) ‚àß Function.Bijective f := sorry", "theorem dummy {X : Type u} [TopologicalSpace X] (s : Set X) : (‚àÉ t : Set X, IsOpen t ‚àß t = s) ‚Üî ‚àÉ t : Set X, IsClosed t ‚àß t = s:= sorry", "theorem dummy (M : Type*) [MetricSpace M] : ‚àÉ (f : Set M ‚Üí Set M), (‚àÄ U : Set M, IsOpen U ‚Üî IsClosed (f U)) ‚àß (‚àÄ U V : Set M, IsOpen U ‚Üí IsOpen V ‚Üí (U = V ‚Üî f U = f V)) := sorry", "theorem dummy [MetricSpace Œ±] : {s : Set Œ± | IsClosed s} = {s : Set Œ± | IsOpen s·∂ú} := sorry", "theorem dummy {Œ± : Type u} [TopologicalSpace Œ±] [MetricSpace Œ±] (s : Set Œ±) : IsClosed s ‚Üî IsOpen (s·∂ú) := sorry", "theorem dummy (M : Type*) [MetricSpace M] : ‚àÉ (f : Set M ‚Üí Set M), (‚àÄ U : Set M, IsOpen U ‚Üí IsClosed (f U)) ‚àß (‚àÄ K : Set M, IsClosed K ‚Üí IsOpen (f K)) ‚àß Function.Bijective f := sorry", "theorem dummy {M : Type*} [MetricSpace M] : ‚àÉ (f : Set M ‚Üí Set M), Bijective f ‚àß ‚àÄ U : Set M, IsOpen U ‚Üî IsClosed (f U) := sorry", "theorem dummy {M : Type _} [MetricSpace M] : Nonempty (Set M ‚âÉ Set M) := sorry", "theorem dummy {M : Type*} [MetricSpace M] : ‚àÉ f : Set M ‚Üí Set M, Function.Bijective f ‚àß ‚àÄ (s : Set M), IsOpen s ‚Üî IsClosed (f s) := sorry", "theorem dummy {X : Type*} [MetricSpace X] : Function.Bijective ({T : Set X | IsOpen T} : Set (Set X)) := sorry", "theorem dummy : Bijection (IsOpen : Set M ‚Üí Prop) (IsClosed : Set M ‚Üí Prop) := sorry", "theorem dummy (M : Type*) [MetricSpace M] : ‚àÉ (f : Set M ‚Üí Set M), (‚àÄ U ‚àà {U : Set M | IsOpen U}, IsClosed (f U)) ‚àß (‚àÄ C ‚àà {C : Set M | IsClosed C}, IsOpen (f‚Åª¬π' {C})) ‚àß Function.Bijective f := sorry", "theorem dummy {X : Type u} [TopologicalSpace X] [T2Space X] {U : Set X} (hU : IsOpen U) : IsClosed U := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [MetricSpace X] : Nonempty (X ‚âÉ {s : Set X // IsOpen s} ‚âÉ {s : Set X // IsClosed s}) := sorry", "theorem dummy (M : Type*) [MetricSpace M] : ‚àÉ (f : Set M ‚Üí Set M), (‚àÄ U ‚àà {U : Set M | IsOpen U}, ‚àÉ! K ‚àà {K : Set M | IsClosed K}, f U = K) ‚àß (‚àÄ K ‚àà {K : Set M | IsClosed K}, ‚àÉ! U ‚àà {U : Set M | IsOpen U}, f K = U) := sorry", "theorem dummy {X : Type _} [MetricSpace X] (U : Set X) (hU : IsOpen U) : ‚àÉ (K : Set X), IsClosed K ‚àß K = U := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-3.465453624725342, -5.885578155517578, -4.726937294006348, -4.851623058319092, -4.940915584564209, -4.209049701690674, -5.466536521911621, -5.452844142913818, -5.570766448974609, -0.5512641072273254, -5.939917087554932, -0.5563110113143921, -5.790030479431152, -5.55441951751709, -4.454035758972168, 0.9705063104629517], "chosen_index": 15}
{"problem_id": "Dummit-Foote|exercise_9_4_11", "nl_statement": "Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$.", "candidates": ["theorem dummy : Irreducible (x ^ 2 + y ^ 2 - 1 : Polynomial ‚Ñ§) := sorry", "theorem dummy {x y : ‚Ñö} : Irreducible (x^2 + y^2 - 1) := sorry", "theorem dummy (x y : ‚Ñö) : Irreducible (x^2 + y^2 - 1) := sorry", "theorem dummy : Irreducible (x ^ 2 + y ^ 2 - 1 : Polynomial (Polynomial ‚Ñö)) := sorry", "theorem dummy : Irreducible (X ^ 2 + Y ^ 2 - 1 : R[X, Y]) := sorry", "theorem dummy {R : Type*} [CommRing R] {P : Polynomial R} (hP : P ‚â† 0) : ¬¨‚àÉ Q R : Polynomial R, P = Q * R := sorry", "theorem dummy [CommRing R] [IsDomain R] (x y : R) : Irreducible (x^2 + y^2-1) := sorry", "theorem dummy : Irreducible (Polynomial.C (1 : ‚Ñö) * (X^2 + Y^2 - 1)) := sorry", "theorem dummy {R : Type*} [CommRing R] [IsDomain R] (P : Polynomial R[X]) : P ‚â† 0 ‚àß ¬¨ ‚àÉ (Q R : Polynomial R[X]), P = Q * R + 1 := sorry", "theorem dummy (x y : Polynomial ‚Ñö) : Irreducible (x^2 + y^2 - 1) := sorry", "theorem dummy : Irreducible (x ^ 2 + y ^ 2 - 1 : R[X, X]) := sorry", "theorem dummy : Irreducible (X^2 + Y^2 - 1 : Polynomial (Polynomial ‚Ñö)) := sorry", "theorem dummy (x y : Polynomial ‚Ñö) : Irreducible (x^2 + y^2 - 1 : Polynomial ‚Ñö) := sorry", "theorem dummy {R : Type*} [Ring R] (p : R[X]) [IsDomain R] [IsNoetherianRing R] (hp : p ‚â† 0) (h2 : ¬¨‚àÉ q r : R[X], r ‚â† 0 ‚àß q * r + p = 1) : ‚àÄ (a b : R), a^2 + b^2 - 1 ‚â† 0 := sorry", "theorem dummy {R : Type*} [CommRing R] (x y : R) : Irreducible (x^2 + y^2 - 1) := sorry", "theorem dummy (x y : ‚Ñö) : Irreducible <| x^2 + y^2 - 1 := sorry", "theorem dummy {R : Type*} [CommRing R] : Irreducible (x^2 + y^2 - 1) := sorry", "theorem dummy : ¬¨ IsUnit (Ideal.span {x^2 + y^2 - 1} : Ideal (Polynomial (FractionRing (Polynomial ‚Ñö)))) := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-5.774072170257568, -5.257081031799316, -5.523954391479492, -3.879706382751465, -5.427926063537598, -5.236175537109375, -5.648896217346191, 1.2696000337600708, -5.671627998352051, -5.3115339279174805, -5.7684221267700195, -0.3913784921169281, -5.813712120056152, -3.420429229736328, -5.738689422607422, -5.175356864929199, -5.84004020690918, -4.559791088104248], "chosen_index": 7}
{"problem_id": "Ireland-Rosen|exercise_5_37", "nl_statement": "Show that if $a$ is negative then $p \\equiv q(4 a)$ together with $p\\not | a$ imply $(a / p)=(a / q)$.", "candidates": ["theorem dummy (ha : a < 0) (h : p ‚â° q [ZMOD 4 * a]) (hp : ¬¨p ‚à£ a) : (a / p) = a / q := sorry", "theorem dummy (ha : a < 0) (h : p ‚â° q [ZMOD 4 * a]) (hp : ¬¨p ‚à£ a) : (a / p) = (a / q) := sorry", "theorem dummy (h : a < 0) (h' : p ‚à£ a) : (a / p : ‚Ñ§) = (a / q : ‚Ñ§) := sorry", "theorem dummy {p q a : ‚Ñï} (h_a_neg : a < 0) (hq : q.Prime) (hp : p ‚â† q) (hq_nmid_a : ¬¨ q ‚à£ a) (h_p_eq : p ‚â° q [MOD 4 * a]): (a / p) = (a / q) := sorry", "theorem dummy {a p q : ‚Ñ§} (ha : a < 0) (hpq : p * q = 4 * a) (hp : ¬¨ p = 0) : (a / p) = (a / q) := sorry", "theorem dummy (a p q : ‚Ñ§) (hp : Prime p) (hq : Prime q) (ha : a < 0) (h : p ‚â° q [ZMOD 4 * a]) (hc : ¬¨p ‚à£ a) : (a / p) = (a / q) := sorry", "theorem dummy [Field K] {a p q : K} (hpq : p * q = 4 * a) (hnp : ¬¨ p ‚à£ a) : (a / p) = (a / q) := sorry", "theorem dummy {a p q : ‚Ñ§} (ha : a < 0) (h : p * (4 * a) ‚â° q [ZMOD p * (4 * a)]) (h' : ¬¨ p ‚à£ a) : (a / p) = (a / q) := sorry", "theorem dummy {p q a : ‚Ñ§} (hp : p < 0) (h : p ‚à£ a * q) (hq : ¬¨p ‚à£ a) : (a / p : ‚Ñ§‚àöd) = (a / q : ‚Ñ§‚àöd) := sorry", "theorem dummy (ha : a < 0) (hpq : p ‚â° q [ZMOD 4 * a]) (pna : ¬¨p ‚à£ a) : a / p = a / q := sorry", "theorem dummy [CommRing R] [IsDomain R] [CharZero R] (p q : ‚Ñï) (hp : Fact (Nat.Prime p)) (hq : Fact (Nat.Prime q)) (hq_pos : Fact (¬¨Even q)) (hq_odd : Fact (¬¨Even q)) (h : ‚àÉ a : ‚Ñ§, p ‚â° q * a * a [ZMOD 4 * a]) : (a / p) = (a / q) := sorry", "theorem dummy (npos : a < 0) (h : p ‚à£ a * q) (h' : ¬¨p ‚à£ a) : (a / p : ‚Ñ§) = (a / q : ‚Ñ§) := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-1.7630367279052734, -2.6056556701660156, -6.0083513259887695, -1.0111446380615234, -3.737549066543579, -4.974180221557617, -4.205962181091309, -3.273333787918091, -5.944170951843262, -2.032012939453125, -5.732349395751953, -6.04208517074585], "chosen_index": 3}
{"problem_id": "Axler|exercise_6_2", "nl_statement": "Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.", "candidates": ["theorem dummy {u v : V} : ‚ü™u, v‚ü´ = 0 ‚Üî ‚àÄ a : F, ‚Äñu‚Äñ ‚â§ ‚Äñu + a ‚Ä¢ v‚Äñ := sorry", "theorem dummy {E : Type*} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E] {u v : E} : (‚ü™u, v‚ü´_‚Ñù = 0) ‚Üî ‚àÄ (a : ‚Ñù), ‚Äñu‚Äñ ‚â§ ‚Äñu + a ‚Ä¢ v‚Äñ := sorry", "theorem dummy {V : Type u} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] {u v : V} : ‚ü™u, v‚ü´_‚Ñù = 0 ‚Üî ‚àÄ a : ‚Ñù, ‚Äñu‚Äñ ‚â§ ‚Äñu + a ‚Ä¢ v‚Äñ := sorry", "theorem dummy {u v : V} : ‚ü™u, v‚ü´ = 0 ‚Üî ‚àÄ a : ùïú, ‚Äñu‚Äñ ‚â§ ‚Äñu + a ‚Ä¢ v‚Äñ := sorry", "theorem dummy {V : Type*} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] {u v : V} (hv : ‚Äñv‚Äñ = 1) : ‚ü™u, v‚ü´_‚Ñù = 0 ‚Üî ‚àÄ a : ‚Ñù, ‚Äñu‚Äñ ‚â§ ‚Äñu + a ‚Ä¢ v‚Äñ := sorry", "theorem dummy {V : Type*} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] {u : V} {v : V} : ‚ü™u, v‚ü´_‚Ñù = 0 ‚Üî ‚àÄ a : ‚Ñù, ‚Äñu‚Äñ ‚â§ ‚Äñu + a ‚Ä¢ v‚Äñ := sorry"], "labels": [0, 0, 0, 0, 0, 0], "scores": [3.0537161827087402, 3.702732801437378, 2.759058713912964, -1.9163671731948853, 4.519718647003174, 4.827957630157471], "chosen_index": 5}
{"problem_id": "Munkres|exercise_16_4", "nl_statement": "A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps.", "candidates": ["theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] : (‚àÄ U : Set (X √ó Y), IsOpen U ‚Üí IsOpen (Prod.fst '' U)) ‚àß (‚àÄ V : Set (X √ó Y), IsOpen V ‚Üí IsOpen (Prod.snd '' V)) := sorry", "theorem dummy (X Y : Type*) [TopologicalSpace X] [TopologicalSpace Y] (f : X ‚Üí Y) (h : ‚àÄ U : Set X, IsOpen U ‚Üí IsOpen (f '' U)) : ‚àÄ U : Set X, IsOpen U ‚Üí IsOpen (f '' U) := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (œÄ‚ÇÅ : X √ó Y ‚Üí X) (œÄ‚ÇÇ : X √ó Y ‚Üí Y) : IsOpenMap œÄ‚ÇÅ ‚àß IsOpenMap œÄ‚ÇÇ := sorry", "theorem dummy (X Y : Type u) [TopologicalSpace X] [TopologicalSpace Y] : IsOpenMap (Prod.fst : X √ó Y ‚Üí X) := sorry", "theorem dummy {f : X ‚Üí Y} (hf : ‚àÄ U, IsOpen U ‚Üí IsOpen (f '' U)) : IsOpenMap f := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace (X √ó Y)] (œÄ‚ÇÅ : X √ó Y ‚Üí X) (œÄ‚ÇÇ : X √ó Y ‚Üí Y) : IsOpenMap œÄ‚ÇÅ ‚àß IsOpenMap œÄ‚ÇÇ := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace (X √ó Y)] (œÄ‚ÇÅ : X √ó Y ‚Üí X) : IsOpenMap œÄ‚ÇÅ := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] : (‚àÄ U : Set (X √ó Y), IsOpen U ‚Üí IsOpen (Prod.fst '' U)) ‚àß (‚àÄ U : Set (X √ó Y), IsOpen U ‚Üí IsOpen (Prod.snd '' U)) := sorry", "theorem dummy : IsOpenMap (@Prod.fst X Y) := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (f : X √ó Y ‚Üí X) : Continuous f ‚àß ‚àÄ U : Set X, IsOpen U ‚Üí IsOpen (f '' (U √óÀ¢ (univ : Set Y))) := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] : IsOpenMap (Prod.fst : X √ó Y ‚Üí X) := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] : IsOpenMap (Prod.fst : X √ó Y ‚Üí X) ‚àß IsOpenMap (Prod.snd : X √ó Y ‚Üí Y) := sorry"], "labels": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], "scores": [7.372632026672363, -6.143877983093262, -5.882147789001465, -4.420200347900391, -5.555024147033691, -5.893255710601807, -5.6757283210754395, 6.983022212982178, -3.8824286460876465, -3.1694648265838623, -2.3548688888549805, 6.626932144165039], "chosen_index": 0}
{"problem_id": "Axler|exercise_1_6", "nl_statement": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$.", "candidates": ["theorem dummy (U : Set (EuclideanSpace ‚Ñù (Fin 2))) (hU : Set.Nonempty U) (hU' : ‚àÄ u v : EuclideanSpace ‚Ñù (Fin 2), u ‚àà U ‚Üí v ‚àà U ‚Üí u + v ‚àà U) (hU'' : ‚àÄ u : EuclideanSpace ‚Ñù (Fin 2), u ‚àà U ‚Üí -u ‚àà U) : ¬¨ (‚àÉ (V : Submodule ‚Ñù (EuclideanSpace ‚Ñù (Fin 2))), U = V) := sorry", "theorem dummy {V : Type*} [AddCommGroup V] [Module ‚Ñù V] : ‚àÉ U : Set V, ‚àÉ u : V, u ‚àà U ‚àß ‚àÄ v w : V, v ‚àà U ‚Üí w ‚àà U ‚Üí v + w ‚àà U ‚àß -v ‚àà U ‚àß ¬¨‚àÉ W : Submodule ‚Ñù V, W = U := sorry", "theorem dummy : ‚àÉ (U : Set (EuclideanSpace ‚Ñù (Fin 2))), U ‚â† ‚àÖ ‚àß (‚àÄ (u : EuclideanSpace ‚Ñù (Fin 2)), u ‚àà U ‚Üí -u ‚àà U) ‚àß ‚àÄ (u v : EuclideanSpace ‚Ñù (Fin 2)), u ‚àà U ‚Üí v ‚àà U ‚Üí u + v ‚àà U := sorry", "theorem dummy : ‚àÉ (U : Set (EuclideanSpace ‚Ñù (Fin 2))), U.Nonempty ‚àß (‚àÄ (x : EuclideanSpace ‚Ñù (Fin 2)), x ‚àà U ‚Üí -x ‚àà U) ‚àß (‚àÄ (x y : EuclideanSpace ‚Ñù (Fin 2)), x ‚àà U ‚Üí y ‚àà U ‚Üí x + y ‚àà U) ‚àß ¬¨(‚àÉ (s : Submodule ‚Ñù (EuclideanSpace ‚Ñù (Fin 2))), s = U) := sorry", "theorem dummy {U : Set (EuclideanSpace ‚Ñù (Fin 2))} : (‚àÉ (u : EuclideanSpace ‚Ñù (Fin 2)), u ‚àà U) ‚àß (‚àÄ (u v : EuclideanSpace ‚Ñù (Fin 2)), u ‚àà U ‚Üí v ‚àà U ‚Üí u + v ‚àà U) ‚àß (‚àÄ (u : EuclideanSpace ‚Ñù (Fin 2)), u ‚àà U ‚Üí -u ‚àà U) ‚Üí ¬¨ IsAddSubgroup U := sorry", "theorem dummy : ‚àÉ U : Set ‚Ñù¬≤, U.Nonempty ‚àß ClosedUnder (¬∑ + ¬∑) U ‚àß ClosedUnder (fun u => -u) U ‚àß ¬¨IsSubspace ‚Ñù U := sorry"], "labels": [0, 0, 0, 1, 0, 0], "scores": [-5.631927490234375, -4.635674476623535, -5.611790180206299, -4.373023509979248, -6.01869010925293, -3.699676990509033], "chosen_index": 5}
{"problem_id": "Putnam|exercise_2010_a4", "nl_statement": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.", "candidates": ["theorem dummy {n : ‚Ñï} (hn : 0 < n) : ¬¨ Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy (n : ‚Ñï) (hn : 0 < n) : ¬¨ Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) := sorry", "theorem dummy {n : ‚Ñï} (n_pos : n > 0) : Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) := sorry", "theorem dummy (n : ‚Ñï) (hn : 0 < n) : ¬¨ Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) := sorry", "theorem dummy (n : ‚Ñï) (hn : 0 < n) : ¬¨ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy {p : ‚Ñï} (h‚ÇÅ : 1 < p) (h‚ÇÇ : ‚àÉ n : ‚Ñï, 10 ^ n ‚â§ p) : ¬¨ Prime p := sorry", "theorem dummy (n : ‚Ñï) : Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ‚Üí False := sorry", "theorem dummy (n : ‚Ñï) : ¬¨(10 ^ 10 ^ 10 ^ n + 10 ^ 10 ^ n + 10 ^ n - 1).Prime := sorry", "theorem dummy {n : ‚Ñï} (h : 1 < n) : ¬¨ Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy (n : ‚Ñï) : ¬¨(10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1).Prime := sorry", "theorem dummy (n : ‚Ñï) : ¬¨Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy (n : ‚Ñï) (hn : 0 < n) : ¬¨ Prime (10 ^ 10 ^ 10 ^ n + (10 ^ 10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy {n : ‚Ñï} (npos : 0 < n) : ¬¨ Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy (n : ‚Ñï) (h : 0 < n) : ¬¨ Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy : ‚àÄ n > 0, ¬¨Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) := sorry", "theorem dummy {m n : ‚Ñï} (hmn : m ‚à£ n) : (10 ^ m - 1) ‚à£ (10 ^ n - 1) := sorry"], "labels": [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], "scores": [6.851845741271973, 6.50292444229126, -0.2880237400531769, 6.176408290863037, 6.173197269439697, -6.112368106842041, -4.969099521636963, -5.524228096008301, -0.14345651865005493, -4.292565822601318, -2.643949508666992, 6.96999454498291, 5.8043107986450195, 5.8648271560668945, -0.7014802694320679, -6.022630214691162], "chosen_index": 11}
{"problem_id": "Dummit-Foote|exercise_1_6_4", "nl_statement": "Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic.", "candidates": ["theorem dummy : ¬¨ ‚àÉ (f : (‚ÑùÀ£) ‚Üí* (‚ÑÇÀ£)), Function.Bijective f := sorry", "theorem dummy : ¬¨Isomorphic (Multiplicative (‚Ñù \\ {0})) (Multiplicative (‚ÑÇ \\ {0})) := sorry", "theorem dummy (f : (Units ‚Ñù) ‚âÉ* (Units ‚ÑÇ)) : False := sorry", "theorem dummy : ¬¨ Nonempty (Multiplicative ‚Ñù ‚âÉ* Multiplicative ‚ÑÇ) := sorry", "theorem dummy : ¬¨ ‚àÉ (f : (‚ÑùÀ£) ‚âÉ* (‚ÑÇÀ£)), True := sorry", "theorem dummy : ¬¨ ‚àÉ (œÜ : (‚ÑùÀ£) ‚âÉ* (‚ÑÇÀ£)), True := sorry", "theorem dummy {G H : Type*} [Group G] [Group H] (f : G ‚âÉ* H) (h1 : ‚àÄ x : G, x ^ 2 = 1) (h2 : ‚àÉ x : H, x ‚â† x‚Åª¬π) : False := sorry", "theorem dummy : ¬¨Nonempty (Units ‚Ñù ‚âÉ* Units ‚ÑÇ) := sorry", "theorem dummy {G : Type*} [Group G] [DivisionMonoid G] (h : ‚àÄ (f : (Multiplicative ‚Ñù) ‚Üí* G), ¬¨Function.Bijective f) : ¬¨‚àÉ f : Multiplicative ‚ÑÇ ‚Üí* G, IsGroupHom f := sorry"], "labels": [1, 0, 1, 1, 1, 1, 0, 1, 0], "scores": [-6.0751471519470215, -5.516488552093506, -5.356153964996338, -5.369327068328857, -5.62556791305542, -5.594333648681641, -5.576576232910156, -5.068365573883057, -6.096499443054199], "chosen_index": 7}
{"problem_id": "Rudin|exercise_1_2", "nl_statement": "Prove that there is no rational number whose square is $12$.", "candidates": ["theorem dummy : ¬¨ ‚àÉ x : ‚Ñö, x^2 = 12 := sorry", "theorem dummy : ¬¨ ‚àÉ (q : ‚Ñö), q^2 = 12 := sorry", "theorem dummy {a : ‚Ñö} : a ^ 2 ‚â† 12 := sorry", "theorem dummy {Q : Type*} [Field Q] [Algebra ‚Ñö Q] : ¬¨ ‚àÉ q : Q, q ^ 2 = 12 := sorry", "theorem dummy : ¬¨ (‚àÉ x : ‚Ñö, x^2 = 12) := sorry", "theorem dummy : ¬¨ ‚àÉ (q : ‚Ñö), q * q = 12 := sorry", "theorem dummy : ¬¨‚àÉ q : ‚Ñö, q ^ 2 = 12 := sorry", "theorem dummy (h : ‚àÉ x : ‚Ñö, x ^ 2 = 12) : False := sorry", "theorem dummy (q : ‚Ñö) : q ^ 2 ‚â† 12 := sorry", "theorem dummy : ¬¨‚àÉ q : ‚Ñö, q^2 = 12 := sorry", "theorem dummy : ¬¨‚àÉ x : ‚Ñö, x ^ 2 = 12 := sorry", "theorem dummy : ¬¨ ‚àÉ (x : ‚Ñö), x ^ 2 = 12 := sorry", "theorem dummy : ¬¨ ‚àÉ q : ‚Ñö, q * q = 12 := sorry", "theorem dummy : ¬¨ ‚àÉ (x : ‚Ñö), x^2 = 12 := sorry", "theorem dummy {q : ‚Ñö} : ¬¨ ‚àÉ q, q * q = 12 := sorry", "theorem dummy : ¬¨IsRat (Real.sqrt 12) := sorry", "theorem dummy : ¬¨ ‚àÉ q : ‚Ñö, q ^ 2 = 12 := sorry", "theorem dummy {q : ‚Ñö} : q ^ 2 ‚â† 12 := sorry", "theorem dummy : ¬¨‚àÉ a : ‚Ñö, a ^ 2 = 2 * 3 := sorry", "theorem dummy : ¬¨ ‚àÉ (q : ‚Ñö), q ^ 2 = 12 := sorry"], "labels": [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1], "scores": [3.0072097778320312, 4.020872116088867, 3.120732545852661, -5.004773139953613, 5.293635845184326, 1.312682867050171, 3.482752561569214, -1.0004894733428955, 5.658803939819336, 4.196026802062988, 3.9568841457366943, 0.5760510563850403, 1.461240291595459, 1.3657433986663818, -4.521008491516113, -4.807542324066162, 2.8930087089538574, 5.095261573791504, -5.830365180969238, 4.550268650054932], "chosen_index": 8}
{"problem_id": "Dummit-Foote|exercise_2_4_16b", "nl_statement": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.", "candidates": ["theorem dummy : (rotationSubgroup : Subgroup (DihedralGroup n)) = Maximal := sorry", "theorem dummy : IsMaximal (rotations : Subgroup DihedralGroup n) := sorry", "theorem dummy {n : ‚Ñï} (hn : 0 < n) : ‚àÉ (H : Subgroup (DihedralGroup n)), H.index = 2 ‚àß (‚àÄ K : Subgroup (DihedralGroup n), H ‚â§ K ‚Üí K = ‚ä§ ‚à® K = H) := sorry", "theorem dummy : IsMaximal (rotations D) := sorry"], "labels": [0, 0, 0, 0], "scores": [6.983895301818848, 2.033367156982422, -5.529862403869629, -2.304615020751953], "chosen_index": 0}
{"problem_id": "Dummit-Foote|exercise_4_5_18", "nl_statement": "Prove that a group of order 200 has a normal Sylow 5-subgroup.", "candidates": ["theorem dummy : (Sylow 5 p).Normal := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] (hG : Fintype.card G = 200) : ‚àÉ P : Sylow 5 G, P.1.Normal := sorry", "theorem dummy {p : ‚Ñï} [Fact p.Prime] [Fintype Œ±] [Group Œ±] [DecidableEq Œ±] (hdvd : p ‚à£ Fintype.card Œ±) (hle : Fintype.card Œ± ‚â§ 200) : IsNormalSylow p Œ± := sorry"], "labels": [0, 1, 0], "scores": [-3.338850736618042, 6.256359100341797, -4.395254135131836], "chosen_index": 1}
{"problem_id": "Dummit-Foote|exercise_5_4_2", "nl_statement": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$.", "candidates": ["theorem dummy : IsNormal H ‚Üî ‚ÅÖG, H‚ÅÜ ‚â§ H := sorry", "theorem dummy {G : Type u} [Group G] (H : Subgroup G) : Normal H ‚Üî ‚àÄ g : G, ‚àÄ h : G, (g * h * g‚Åª¬π * h‚Åª¬π) ‚àà H := sorry", "theorem dummy {G : Type*} [Group G] (H : Subgroup G) : H.Normal ‚Üî ‚àÄ g : G, g ‚àà H ‚Üí ‚àÄ h : G, h ‚àà H ‚Üí g * h * g‚Åª¬π * h‚Åª¬π ‚àà H := sorry", "theorem dummy {H : Subgroup G} : H.Normal ‚Üî [G, H] ‚â§ H := sorry", "theorem dummy {G : Type*} [Group G] (H : Subgroup G) (h : commutator G ‚â§ H) : H.Normal := sorry"], "labels": [0, 0, 0, 0, 0], "scores": [-4.915314674377441, -4.915839195251465, -2.291470766067505, -3.8607420921325684, -4.102055549621582], "chosen_index": 2}
{"problem_id": "Dummit-Foote|exercise_4_5_28", "nl_statement": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.", "candidates": ["theorem dummy : IsAbelian G := sorry", "theorem dummy {G : Type _} [Group G] [Fintype G] [DecidableEq G] (hG : Fintype.card G = 105) (h : (sylow 3 G).Normal ‚Üí IsAbelian G) : IsAbelian G := sorry"], "labels": [0, 0], "scores": [-4.5185770988464355, -1.5531597137451172], "chosen_index": 1}
{"problem_id": "Dummit-Foote|exercise_4_4_7", "nl_statement": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.", "candidates": ["theorem dummy (H : Subgroup G) [Unique H] : IsCharacteristic G H := sorry", "theorem dummy (H : Subgroup G) [Unique (Subgroup G)] : H.Characteristic G := sorry", "theorem dummy [Group G] (H : Subgroup G) [IsCyclic H] (n : ‚Ñï) (hn : Subgroup.index H = n) (x : G) (hx : x ‚àà H) (hnx : x^n = 1) : x = 1 := sorry"], "labels": [0, 0, 0], "scores": [0.24429914355278015, 3.940363883972168, -3.020887851715088], "chosen_index": 1}
{"problem_id": "Putnam|exercise_2018_b2", "nl_statement": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$.", "candidates": ["theorem dummy {n : ‚Ñï} (hn : 0 < n) : ‚àÄ z ‚àà closedBall (0 : ‚ÑÇ) 1, f n z ‚â† 0 := sorry", "theorem dummy [Group G] {P : Subgroup G} (hP : IsPGroup p P) : ‚àÉ Q : Sylow p G, P ‚â§ Q := sorry", "theorem dummy (n : ‚Ñï) : ‚àÄ z ‚àà closedBall (0 : ‚ÑÇ) 1, f n z ‚â† 0 := sorry", "theorem dummy (n : ‚Ñï) : ‚àÄ z : ‚ÑÇ, z ‚àà Metric.closedBall 0 1 ‚Üí ¬¨(n + (n - 1) * z + (n - 2) * z ^ 2 + (n - 3) * z ^ 3 + (n - 4) * z ^ 4 + (n - 5) * z ^ 5 = 0) := sorry", "theorem dummy (n : ‚Ñï) (hn : n ‚â† 0) : ‚àÉ z : ‚ÑÇ, z ‚â† 0 ‚àß z ‚â† 1 ‚àß z ‚â† -1 ‚àß ‚àÄ i : Fin n, z ^ (i : ‚Ñï) - 1 ‚â† 0 := sorry"], "labels": [0, 0, 0, 0, 0], "scores": [3.122499942779541, -6.1949687004089355, 0.3949061334133148, -4.882568359375, -4.489543914794922], "chosen_index": 0}
{"problem_id": "Axler|exercise_7_14", "nl_statement": "Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$.", "candidates": ["theorem dummy {T : V ‚Üí‚Çó[K] V} (hT : IsSelfAdjoint T) {Œª : K} {Œµ : K} (hŒµ : 0 < Œµ) (hŒª : ‚àÉ v : V, ‚Äñv‚Äñ = 1 ‚àß ‚ÄñT v - Œª ‚Ä¢ v‚Äñ < Œµ) : ‚àÉ Œª' : K, ‚ÄñŒª - Œª'‚Äñ < Œµ := sorry", "theorem dummy (hT : IsSelfAdjoint T) {Œª : ùïú} {Œµ : ùïú} (hŒµ : 0 < Œµ) : (‚àÉ v : V, ‚Äñv‚Äñ = 1 ‚àß ‚ÄñT v - Œª ‚Ä¢ v‚Äñ < Œµ) ‚Üí ‚àÉ Œª' : ùïú, ‚ÄñŒª - Œª'‚Äñ < Œµ := sorry"], "labels": [0, 0], "scores": [-1.4933265447616577, -3.466038703918457], "chosen_index": 0}
{"problem_id": "Dummit-Foote|exercise_8_3_6b", "nl_statement": "Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.", "candidates": ["theorem dummy {q : ‚Ñï} (hq : q % 4 = 3) (hq_prime : Nat.Prime q) : IsField (ZMod (Int.natAbs q)) := sorry", "theorem dummy (q : ‚Ñï) [Fact (Nat.Prime q)] (hq : q % 4 = 3) : Fintype.card (ZMod q) = q^2 := sorry", "theorem dummy (q : ‚Ñï) [Fact (q.Prime)] (hq : q ‚â° 3 [MOD 4]) : Fintype.card (ZMod q) = q^2 := sorry", "theorem dummy {q : ‚Ñï} [Fact q.Prime] (hq : q % 4 = 3) : IsField (ZMod q) := sorry", "theorem dummy {q : ‚Ñï} [Fact (Nat.Prime q)] (hq : q ‚â° 3 [MOD 4]) : IsField (Zsqrtd q) := sorry"], "labels": [0, 0, 0, 0, 0], "scores": [8.065494537353516, 5.049422264099121, 4.937853813171387, 7.381683826446533, 6.493903636932373], "chosen_index": 0}
{"problem_id": "Axler|exercise_6_3", "nl_statement": "Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.", "candidates": ["theorem dummy {n : ‚Ñï} {a : Fin n ‚Üí ‚Ñù} {b : Fin n ‚Üí ‚Ñù} : ‚àë (j : Fin n), a j * b j ^ 2 ‚â§ (‚àë (j : Fin n), j * a j ^ 2) * (‚àë (j : Fin n), (b j ^ 2) / j) := sorry", "theorem dummy (n : ‚Ñï) (a b : Fin n ‚Üí ‚Ñù) : (‚àë j, a j * b j) ^ 2 ‚â§ (‚àë j, j * (a j) ^ 2) * (‚àë j, (b j) ^ 2 / j) := sorry", "theorem dummy {n : ‚Ñï} {a : Fin n ‚Üí ‚Ñù} {b : Fin n ‚Üí ‚Ñù} : (‚àë i, a i * b i) ^ 2 ‚â§ (‚àë i, i * a i ^ 2) * (‚àë i, (b i ^ 2) / i) := sorry", "theorem dummy {n : ‚Ñï} {a b : Fin n ‚Üí ‚Ñù} : (‚àë j : Fin n, a j * b j)^2 ‚â§ (‚àë j : Fin n, (j : ‚Ñù) * a j^2) * ‚àë j : Fin n, b j^2 / j := sorry", "theorem dummy (n : ‚Ñï) (a : Fin n ‚Üí ‚Ñù) (b : Fin n ‚Üí ‚Ñù) : (‚àë i, a i * b i)^2 ‚â§ (‚àë i, i * a i^2) * (‚àë j, b j^2 / j) := sorry", "theorem dummy {n : ‚Ñï} {a b : Fin n ‚Üí ‚Ñù} : (‚àë j, a j * b j)^2 ‚â§ (‚àë j, j * a j^2) * (‚àë j, b j^2 / j) := sorry", "theorem dummy {n : ‚Ñï} (h : n ‚â† 0) {a b : Fin n ‚Üí ‚Ñù} : (‚àë i, a i * b i) ^ 2 ‚â§ (‚àë i, i * a i ^ 2) * ‚àë i, b i ^ 2 / i := sorry", "theorem dummy {n : ‚Ñï} (a b : Fin n ‚Üí ‚Ñù) : (‚àë i, a i * b i)^2 ‚â§ ‚àë i, i * a i^2 * (1/(i : ‚Ñù)) * ‚àë j, j * b j^2 / (j : ‚Ñù) := sorry", "theorem dummy {n : ‚Ñï} {a b : Fin n ‚Üí ‚Ñù} : (‚àë j, a j * b j) ^ 2 ‚â§ (‚àë j, (j + 1) * (a j) ^ 2) * (‚àë j, (b j) ^ 2 / (j + 1)) := sorry", "theorem dummy {n : ‚Ñï} {a : Fin n ‚Üí ‚Ñù} {b : Fin n ‚Üí ‚Ñù} : (‚àë i, a i * b i) ^ 2 ‚â§ (‚àë i, i * a i ^ 2) * (‚àë i, b i ^ 2 / i) := sorry", "theorem dummy {n : ‚Ñï} (a b : ‚Ñï ‚Üí ‚Ñù) : (‚àë i in Finset.range n, a i * b i)^2 ‚â§ (‚àë i in Finset.range n, (i : ‚Ñù) * (a i)^2) * ‚àë i in Finset.range n, (b i)^2 / (i : ‚Ñù) := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], "scores": [-5.236771583557129, -2.800870895385742, -5.393630027770996, -2.4503836631774902, -5.943880081176758, -5.826841831207275, -5.763873100280762, -5.730397701263428, 2.7895870208740234, -5.877438068389893, -4.999496936798096], "chosen_index": 8}
{"problem_id": "Herstein|exercise_5_4_3", "nl_statement": "If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.", "candidates": ["theorem dummy {a : ‚ÑÇ} (ha : eval a p = 0) : degree p ‚â§ 80 := sorry", "theorem dummy {p : ‚Ñö[X]} (h : p.eval a = 0) (hp : natDegree p ‚â§ 80) : IsAlgebraic ‚Ñö a := sorry", "theorem dummy : ¬¨ (‚àÉ (a : ‚Ñù), (a^5 + (sqrt 2) * a^3 + (sqrt 5) * a^2 + (sqrt 7) * a + (sqrt 11) : ‚Ñù) = 0) := sorry", "theorem dummy {K : Type*} [Field K] (p : K[X]) (a : K) (h : p.eval a = 0) : (minpoly K a).degree ‚â§ natDegree p := sorry", "theorem dummy (a : ‚ÑÇ) (h : a ^ 5 + ‚àö(2 : ‚Ñù) * a ^ 3 + ‚àö(5 : ‚Ñù) * a ^ 2 + ‚àö(7 : ‚Ñù) * a + ‚àö(11 : ‚Ñù) = 0) : IsAlgebraic ‚Ñö a := sorry", "theorem dummy {Œ± : ‚Ñù} (hŒ±_irrat : Irrational Œ±) : Dense (Set.range fun n : ‚Ñ§ => Œ± * ‚Üën) := sorry", "theorem dummy (p : Polynomial ‚Ñö) (h0 : p ‚â† 0) (h : p.natDegree = 5) (ha : a ‚àà roots p) : ‚àÉ q ‚àà {q : Polynomial ‚Ñö | Irreducible q ‚àß q.natDegree ‚â§ 80}, q ‚à£ p := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0], "scores": [-5.949566841125488, -5.870509147644043, -4.564286231994629, -5.8084611892700195, -5.9850311279296875, -6.1159281730651855, -4.695709705352783], "chosen_index": 2}
{"problem_id": "Munkres|exercise_22_2a", "nl_statement": "Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.", "candidates": ["theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : C(X, Y)) (f : C(Y, X)) (hf : Function.Surjective f) (h : p ‚àò f = id) : QuotientMap p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : X ‚Üí Y) (hp : Continuous p) (f : Y ‚Üí X) (hf : Continuous f) (h : p ‚àò f = id) : QuotientMap p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : X ‚Üí Y) (f : Y ‚Üí X) (hf : Continuous f) (h : p ‚àò f = id) : Continuous p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : X ‚Üí Y) (f : Y ‚Üí X) (hpf : (p ‚àò f) = id) (hf : Continuous f) : QuotientMap p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {p : X ‚Üí Y} (h : ‚àÉ f : Y ‚Üí X, p ‚àò f = id) : Continuous p ‚Üî ‚àÄ q : Set Y, IsOpen q ‚Üí IsOpen (p ‚Åª¬π' q) := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : X ‚Üí Y) (f : Y ‚Üí X) (h : Continuous f) (hleft : p ‚àò f = id) : QuotientMap p := sorry", "theorem dummy [TopologicalSpace X] [TopologicalSpace Y] (p : ContinuousMap X Y) (f : ContinuousMap Y X) (hf : ‚àÄ y, p (f y) = y) : QuotientMap p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : X ‚Üí Y) (f : Y ‚Üí X) (hpf : ‚àÄ y, p (f y) = y) (hf : Continuous f) : QuotientMap p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {p : X ‚Üí Y} (f : Y ‚Üí X) (hf : Continuous f) (hfip : p ‚àò f = id) : QuotientMap p := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X ‚Üí Y} (hf : Continuous f) {g : Y ‚Üí X} (hg : Continuous g) (h : g ‚àò f = id) : IsOpenMap f := sorry", "theorem dummy {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (p : X ‚Üí Y) (hp : Continuous p) (f : Y ‚Üí X) (hf : Continuous f) (hpf : ‚àÄ y : Y, p (f y) = y) : QuotientMap p := sorry"], "labels": [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], "scores": [-4.891928672790527, -1.1650595664978027, -5.251610279083252, -4.894068717956543, -6.138933181762695, -4.820687770843506, 2.865018367767334, -5.318006992340088, -3.394374370574951, -2.9470033645629883, 1.8154186010360718], "chosen_index": 6}
{"problem_id": "Ireland-Rosen|exercise_4_11", "nl_statement": "Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.", "candidates": ["theorem dummy {p : ‚Ñï} [Fact p.Prime] {k : ‚Ñï} (hk : k ‚à£ (p - 1) ‚Üí False) : ‚àë i in Finset.range (p - 1), i ^ k ‚â° 0 [MOD p] := sorry", "theorem dummy (p : ‚Ñï) [Fact p.Prime] (k : ‚Ñï) : (‚àë i in Finset.range (p - 1), (i : ‚Ñï) ^ k) ‚â° 0 [MOD p] := sorry", "theorem dummy {p k : ‚Ñï} [hp : Fact (Nat.Prime p)] : (‚àë i in Finset.range p, i ^ k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry", "theorem dummy {p : ‚Ñï} (hp : Fact p.Prime) {k : ‚Ñï} (hkp : ¬¨k ‚à£ p - 1) : ‚àë i in Finset.range (p - 1), i ^ k ‚â° 0 [MOD p] := sorry", "theorem dummy {p k : ‚Ñï} (hp : Nat.Prime p) : (‚àë i in Finset.range (p - 1), i^k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry", "theorem dummy {p k : ‚Ñï} [hp : Fact p.Prime] : (‚àë i in Finset.range p, i^k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry", "theorem dummy {p : ‚Ñï} (hp : p.Prime) (k : ‚Ñï) : ‚àë i in Finset.range p, (i : ‚Ñ§) ^ k % p = if p - 1 ‚à£ k then -1 else 0 := sorry", "theorem dummy {p k : ‚Ñï} [Fact p.Prime] : (‚àë i in Finset.range p, i^k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry", "theorem dummy {p k:‚Ñï} (hp:Nat.Prime p) (hp1 : p ‚â† 2) (hk: ¬¨ (p-1 : ‚Ñï) ‚à£ k) : ‚àë i in Finset.range p, i^k = 0 ‚à® ‚àë i in Finset.range p, i^k = -(1 : ‚Ñ§) := sorry", "theorem dummy {p : ‚Ñï} [Fact p.Prime] {k : ‚Ñï} (h : k % (p - 1) = 0) : ((Finset.range (p - 1)).sum fun i => (Nat.fib (i + 1)) ^ k) ‚â° 0 [MOD p] := sorry", "theorem dummy {p n : ‚Ñï} (hprime : Nat.Prime p) (hn : n < p) (h : ¬¨ p - 1 ‚à£ n) : (‚àë i in Finset.range p, i ^ n) % p = p - 1 := sorry", "theorem dummy {p k : ‚Ñï} [hp : Fact (Nat.Prime p)] : (‚àë i in Finset.range (p - 1), i ^ k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry", "theorem dummy (p k : ‚Ñï) (hp : p.Prime) (h : k % (p - 1) ‚â† 0) : ‚àÉ n : ‚Ñï, (‚àë i in Finset.range p, i ^ k = n * p) := sorry", "theorem dummy {p : ‚Ñï} (hp : Nat.Prime p) (k : ‚Ñï) (hk : ¬¨ p - 1 ‚à£ k) : ‚àë i in Finset.range p, i ^ k ‚â° 0 [MOD p] := sorry", "theorem dummy {p k : ‚Ñï} [hp : Fact (Nat.Prime p)] : (‚àë i in Finset.range (p - 1), i^k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry", "theorem dummy {p : ‚Ñï} (k : ‚Ñï) (hp : Nat.Prime p) (h : p - 1 ‚à£ k) : (‚àë i in Finset.range (p - 1), (i : ‚Ñï) ^ k) ‚â° 0 [MOD p] := sorry", "theorem dummy {p k : ‚Ñï} [Fact p.Prime] : (‚àë i in Finset.range (p - 1), i ^ k) % p = if (p - 1) ‚à£ k then p - 1 else 0 := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-6.107114791870117, -5.350115776062012, -3.9887900352478027, -5.919371604919434, 0.1251959204673767, -2.72415828704834, -5.745547294616699, -1.413172960281372, -5.6191325187683105, -5.951398849487305, -3.7309274673461914, -3.911777973175049, -2.905928134918213, -5.8323869705200195, -2.004272222518921, -5.735755443572998, -2.4191513061523438], "chosen_index": 4}
{"problem_id": "Munkres|exercise_30_10", "nl_statement": "Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.", "candidates": ["theorem dummy {Œπ : Type*} [Countable Œπ] {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] (h : ‚àÄ i, ‚àÉ D : Set (X i), D.Countable ‚àß Dense D) : ‚àÉ D : Set (‚àÄ i, X i), D.Countable ‚àß Dense D := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] {Œπ : Type*} [Countable Œπ] {œÄ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (œÄ i)] (h : ‚àÄ i, ‚àÉ S : Set (œÄ i), S.Countable ‚àß Dense S) : ‚àÉ S : Set (‚àÄ i, œÄ i), S.Countable ‚àß Dense S := sorry", "theorem dummy {Œπ : Type*} [Countable Œπ] {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] (h : ‚àÄ i, ‚àÉ D : Set (X i), Countable D ‚àß Dense D) : ‚àÉ D : Set (Œ† i, X i), Countable D ‚àß Dense D := sorry", "theorem dummy {Œπ : Type*} [Fintype Œπ] {X : Œπ ‚Üí Type*} [Nonempty Œπ] [‚àÄ i, TopologicalSpace (X i)] (hX : ‚àÄ i, ‚àÉ (s : Set (X i)), Countable s ‚àß Dense s) : ‚àÉ (s : Set (‚àÄ i, X i)), Countable s ‚àß Dense s := sorry", "theorem dummy {Œπ : Type*} [Countable Œπ] {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] (h : ‚àÄ i, ‚àÉ D : Set (X i), D.Countable ‚àß Dense D) : ‚àÉ D : Set (Œ† i, X i), D.Countable ‚àß Dense D := sorry", "theorem dummy {Œπ : Type*} [Countable Œπ] {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] (h : ‚àÄ i, ‚àÉ S : Set (X i), S.Countable ‚àß Dense S) : ‚àÉ S : Set (‚àÄ i, X i), S.Countable ‚àß Dense S := sorry", "theorem dummy {Œπ : Type*} (X : Œπ ‚Üí Type*) [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, Countable (X i)] (hX : ‚àÄ i, ‚àÉ D : Set (X i), Dense D) : ‚àÉ D : Set (‚àÄ i, X i), Dense D := sorry", "theorem dummy {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] (hX : ‚àÄ i, SeparableSpace (X i)) (s : ‚àÄ i, Countable (X i)) : ‚àÉ t : Set (‚àÄ i, X i), Countable t ‚àß Dense t := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [T2Space X] (hX : Countable X) (B : ‚Ñï ‚Üí Set X) (hB : ‚àÄ n, IsOpen (B n)) (hB' : ‚àÄ x, ‚àÉ n, x ‚àà B n) (hB'' : ‚àÄ n, Dense (B n)) : ‚àÉ D : Set X, Countable D ‚àß Dense D := sorry", "theorem dummy {X : Type u_1} {Œ∫ : Type u_2} [TopologicalSpace X] [T2Space X] (s : Œ∫ ‚Üí Set X) (hs : ‚àÄ (i : Œ∫), Dense (s i)) (hX : SecondCountableTopology X) (hŒ∫ : Countable Œ∫) : ‚àÉ (t : Set X), Dense t ‚àß t.Countable := sorry"], "labels": [1, 1, 1, 0, 1, 1, 0, 0, 0, 0], "scores": [5.969192981719971, 4.877987384796143, 5.7283935546875, -3.9055416584014893, 6.227920055389404, 6.071683406829834, -4.809689998626709, -5.391144752502441, -5.1594133377075195, -6.091923236846924], "chosen_index": 4}
{"problem_id": "Dummit-Foote|exercise_9_4_2a", "nl_statement": "Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.", "candidates": ["theorem dummy {R : Type*} [Ring R] [IsDomain R] (f : R[X]) (h : f = X ^ 4 - 4 * X ^ 3 + 6) : ¬¨ ‚àÉ (p q : R[X]), p * q = f ‚àß 0 < degree p ‚àß 0 < degree q := sorry", "theorem dummy {R : Type*} [Ring R] [IsDomain R] {p : R[X]} (h : p = X^4 - 4 * X^3 + 6) : Irreducible p := sorry", "theorem dummy {p : ‚Ñï} [Fact (Nat.Prime p)] (f : Polynomial (ZMod p)) (hf : f.Monic) (hfd : f.degree > 1) (hp : ‚àÄ (x : ‚Ñï), x < p ‚Üí p ‚à£ x^p - x) : Irreducible f := sorry", "theorem dummy {R : Type*} [CommRing R] (x : R) : Irreducible (x^4 - 4*x^3 + 6) := sorry", "theorem dummy : Irreducible (Polynomial.X ^ 4 - 4 * Polynomial.X ^ 3 + 6 : Polynomial ‚Ñ§) := sorry", "theorem dummy (f : Polynomial ‚Ñ§) (hf : f = X ^ 4 - 4 * X ^ 3 + 6) : Irreducible f := sorry", "theorem dummy : Irreducible (Polynomial.X^4 - 4*Polynomial.X^3 + 6 : Polynomial ‚Ñ§) := sorry", "theorem dummy (x : ‚Ñ§[X]) : Irreducible (x^4 - 4*x^3 + 6) := sorry", "theorem dummy {R : Type*} [CommRing R] [IsDomain R] [CharZero R] (f : R[X]) (h : f = X^4 - 4 * X^3 + 6) : ¬¨ ‚àÉ (g : R[X]) (h : R[X]), f = g * (X - 1) * (X - 2) * (X - 3) := sorry", "theorem dummy : Irreducible (X^4 - 4*X^3 + 6 : Polynomial ‚Ñ§) := sorry", "theorem dummy : Irreducible (Polynomial.C (6 : ‚Ñ§) + Polynomial.C (-4 : ‚Ñ§) * Polynomial.X ^ 3 + Polynomial.X ^ 4) := sorry"], "labels": [0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1], "scores": [-5.928440093994141, -4.73943567276001, -5.907831192016602, -5.90975284576416, 3.67181396484375, -1.0858664512634277, 6.068292140960693, -5.815249443054199, -5.930611610412598, -3.0121803283691406, 1.1118030548095703], "chosen_index": 6}
{"problem_id": "Artin|exercise_10_1_13", "nl_statement": "An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.", "candidates": ["theorem dummy (R : Type*) [Ring R] (x : R) (hx : IsNilpotent x) : IsUnit (1 + x) := sorry", "theorem dummy {R : Type*} [Ring R] (x : R) (hx : IsNilpotent x) : IsUnit (1 + x) := sorry", "theorem dummy {R : Type*} [Ring R] {x : R} (hx : IsNilpotent x) : IsUnit (1 + x) := sorry", "theorem dummy {R : Type*} [Ring R] {x : R} (hx : ‚àÉ n : ‚Ñï, x ^ n = 0) : IsUnit (1 + x) := sorry", "theorem dummy {R : Type*} [Ring R] (x : R) (h : ‚àÉ n : ‚Ñï, x ^ n = 0) : IsUnit (1 + x) := sorry", "theorem dummy {R : Type*} [Ring R] (x : R) (hx : ‚àÉ n : ‚Ñï, x ^ n = 0) : IsUnit (1 + x) := sorry", "theorem dummy {R : Type*} [Ring R] [Nontrivial R] {x : R} (hx : IsNilpotent x) : IsUnit (1 + x) := sorry"], "labels": [1, 1, 1, 1, 1, 1, 0], "scores": [4.903167724609375, 5.195681571960449, 4.661630630493164, 5.5318403244018555, 6.204900741577148, 5.761466026306152, 2.898841619491577], "chosen_index": 4}
{"problem_id": "Dummit-Foote|exercise_8_2_4", "nl_statement": "Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.", "candidates": ["theorem dummy (R : Type*) [CommRing R] [IsDomain R] (h : ‚àÄ a b : R, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí ‚àÉ d r s, d ‚à£ a ‚àß d ‚à£ b ‚àß d = r * a + s * b) (h2 : ‚àÄ (a‚ÇÅ a‚ÇÇ a‚ÇÉ : R), a‚ÇÅ ‚â† 0 ‚Üí a‚ÇÇ ‚â† 0 ‚Üí a‚ÇÉ ‚â† 0 ‚Üí (‚àÉ N : ‚Ñï, ‚àÄ n : ‚Ñï, n ‚â• N ‚Üí a‚ÇÅ * a‚ÇÇ ^ n * a‚ÇÉ ^ n = 1)) : IsPrincipalIdealRing R := sorry", "theorem dummy {R : Type*} [CommRing R] (hR : IsDomain R) (hgcd : ‚àÄ a b : R, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí ‚àÉ d, ‚àÉ r s : R, d = r * a + s * b ‚àß ‚àÄ t : R, t ‚à£ a ‚Üí t ‚à£ b ‚Üí t ‚à£ d) (hnoetherian : ‚àÄ a : ‚Ñï ‚Üí R, (‚àÄ n : ‚Ñï, a (n + 1) ‚à£ a n) ‚Üí ‚àÉ N : ‚Ñï, ‚àÄ n : ‚Ñï, n ‚â• N ‚Üí IsUnit (a n)): IsPrincipalIdealRing R := sorry", "theorem dummy {R : Type*} [CommRing R] (H : IsDomain R) (H1 : ‚àÄ a b : R, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí ‚àÉ d x y, d ‚à£ a ‚àß d ‚à£ b ‚àß x * a + y * b = d) (H2 : ‚àÄ a : R, a ‚â† 0 ‚Üí ‚àÉ n‚ÇÄ : ‚Ñï, ‚àÄ n : ‚Ñï, n‚ÇÄ ‚â§ n ‚Üí IsUnit (a * a^n)) : IsPrincipalIdealRing R := sorry", "theorem dummy (R : Type*) [CommRing R] [IsDomain R] (h1 : ‚àÄ a b : R, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí ‚àÉ d r s : R, d ‚à£ a ‚àß d ‚à£ b ‚àß d = r * a + s * b) (h2 : ‚àÄ (a : ‚Ñï ‚Üí R), (‚àÄ i, a (i + 1) ‚à£ a i) ‚Üí ‚àÉ N, ‚àÄ n ‚â• N, IsUnit (a n) ‚Üî IsUnit (a N)) : IsPrincipalIdealRing R := sorry", "theorem dummy (R : Type*) [CommRing R] [IsDomain R] (h1 : ‚àÄ (a b : R) (ha : a ‚â† 0) (hb : b ‚â† 0), ‚àÉ (d : R) (r s : R), d ‚à£ a ‚àß d ‚à£ b ‚àß d = r * a + s * b) (h2 : ‚àÄ (a : ‚Ñï ‚Üí R) (h : ‚àÄ i, a (i + 1) ‚à£ a i) (n : ‚Ñï), ‚àÉ N, ‚àÄ m ‚â• N, IsUnit (a m) ‚Üî IsUnit (a n)) : IsPrincipalIdealRing R := sorry"], "labels": [0, 0, 0, 0, 0], "scores": [-3.5113089084625244, 0.16828280687332153, -3.0339314937591553, -0.009340822696685791, 0.393825888633728], "chosen_index": 4}
{"problem_id": "Rudin|exercise_3_5", "nl_statement": "For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.", "candidates": ["theorem dummy (a b : ‚Ñï ‚Üí ‚Ñù) : limsup (a + b) ‚â§ limsup a + limsup b := sorry", "theorem dummy {a b : ‚Ñï ‚Üí ‚Ñù} (ha : Tendsto (fun n => a n) atTop atTop) (hb : Tendsto (fun n => b n) atTop atTop) : Tendsto (fun n => a n + b n) atTop atTop ‚àß limsup (fun n => a n + b n) ‚â§ limsup (fun n => a n) + limsup (fun n => b n) := sorry", "theorem dummy {f g : ‚Ñï ‚Üí ‚Ñù} : limsup (fun n => f n + g n) ‚â§ limsup f + limsup g := sorry", "theorem dummy {a b : ‚Ñï ‚Üí ‚Ñù} (haa : Tendsto a atTop atTop) (hbb : Tendsto b atTop atTop) (ha : ‚àÉ l, Tendsto a atTop (ùìù l)) (hb : ‚àÉ l, Tendsto b atTop (ùìù l)) : limsup (a + b) ‚â§ limsup a + limsup b := sorry", "theorem dummy {a b : ‚Ñï ‚Üí ‚Ñù} (ha : BddAbove (Set.range a)) (hb : BddAbove (Set.range b)): limsup (fun n => a n + b n) ‚â§ limsup a + limsup b := sorry"], "labels": [0, 0, 0, 0, 0], "scores": [-5.81391716003418, -5.433481216430664, -5.641801834106445, -5.971585273742676, -5.937932968139648], "chosen_index": 1}
{"problem_id": "Pugh|exercise_3_1", "nl_statement": "Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.", "candidates": ["theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ t x : ‚Ñù, |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : ‚Ñù, f = Function.const ‚Ñù c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ t x, abs (f t - f x) ‚â§ abs (t - x)^2) : ‚àÉ c : ‚Ñù, f = const ‚Ñù c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ t x : ‚Ñù, abs (f t - f x) ‚â§ (abs (t - x))^2) : ‚àÄ x y : ‚Ñù, f x = f y := sorry", "theorem dummy (f : ‚Ñù ‚Üí ‚Ñù) (hf : ‚àÄ t x : ‚Ñù, |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : ‚Ñù, ‚àÄ x : ‚Ñù, f x = c := sorry", "theorem dummy (f : ‚Ñù ‚Üí ‚Ñù) (h : ‚àÄ t x : ‚Ñù, |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : ‚Ñù, ‚àÄ x : ‚Ñù, f x = c := sorry", "theorem dummy {R : Type*} [LinearOrderedField R] {f : R ‚Üí R} (hf : ‚àÄ t x : R, |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : R, ‚àÄ t, f t = c := sorry", "theorem dummy {R : Type*} [LinearOrderedField R] [OrderedAddCommGroup R] {f : R ‚Üí R} (h : ‚àÄ (t x : R), |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : R, ‚àÄ (x : R), f x = c := sorry", "theorem dummy {R : Type*} [LinearOrderedField R] (f : R ‚Üí R) (hf : ‚àÄ (t x : R), |f t - f x| ‚â§ |t - x| ^ 2) : ‚àÉ c, ‚àÄ t, f t = c := sorry", "theorem dummy [CompleteSpace ‚Ñù] (f : ‚Ñù ‚Üí ‚Ñù) (hf : ‚àÄ (t x : ‚Ñù), |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : ‚Ñù, ‚àÄ (x : ‚Ñù), f x = c := sorry", "theorem dummy (f : ‚Ñù ‚Üí ‚Ñù) (hf : ‚àÄ t x, abs (f t - f x) ‚â§ abs (t - x)^2) : ‚àÉ c : ‚Ñù, ‚àÄ x, f x = c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ (x y : ‚Ñù), |f x - f y| ‚â§ |x - y|^2) : ‚àÉ (c : ‚Ñù), ‚àÄ (x : ‚Ñù), f x = c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ t x : ‚Ñù, |f t - f x| ‚â§ |t - x| ^ 2) : ‚àÉ c : ‚Ñù, f = const ‚Ñù c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ t x : ‚Ñù, abs (f t - f x) ‚â§ abs (t - x) ^ 2) : ‚àÉ c : ‚Ñù, f = const ‚Ñù c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ t x, |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : ‚Ñù, f = const ‚Ñù c := sorry", "theorem dummy (f : ‚Ñù ‚Üí ‚Ñù) (hf : ‚àÄ t x, abs (f t - f x) ‚â§ abs (t - x) ^ 2) : ‚àÉ c : ‚Ñù, ‚àÄ t, f t = c := sorry", "theorem dummy {f : ‚Ñù ‚Üí ‚Ñù} (h : ‚àÄ t x : ‚Ñù, |f t - f x| ‚â§ |t - x|^2) : ‚àÉ c : ‚Ñù, ‚àÄ x : ‚Ñù, f x = c := sorry"], "labels": [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], "scores": [-4.50112247467041, -2.5363192558288574, -5.110507488250732, -5.831583023071289, -5.898937225341797, -2.7268714904785156, -5.791431903839111, -4.561024188995361, -6.007774353027344, -1.1592071056365967, -5.981379508972168, -4.926105976104736, -3.9673385620117188, -4.746962547302246, -2.002931594848633, -5.854976654052734], "chosen_index": 9}
{"problem_id": "Artin|exercise_3_2_7", "nl_statement": "Prove that every homomorphism of fields is injective.", "candidates": ["theorem dummy {K L : Type*} [Field K] [Field L] (f : K ‚Üí+* L) : Injective f := sorry", "theorem dummy (F E : Type*) [Field F] [Field E] (f : F ‚Üí+* E) : Function.Injective f := sorry", "theorem dummy {K L : Type*} [Field K] [Field L] (œÜ : K ‚Üí+* L) : Function.Injective œÜ := sorry", "theorem dummy {K L : Type*} [Field K] [Field L] (f : K ‚Üí* L) : Function.Injective f := sorry", "theorem dummy (F G : Type*) [Field F] [Field G] (f : F ‚Üí+* G) : Function.Injective f := sorry", "theorem dummy {K L : Type*} [Field K] [Field L] (f : K ‚Üí* L) : Injective f := sorry", "theorem dummy {F E : Type*} [Field F] [Field E] (f : F ‚Üí+* E) : Function.Injective f := sorry", "theorem dummy {K L : Type*} [Field K] [Field L] (f : K ‚Üí+* L) : Function.Injective f := sorry"], "labels": [1, 1, 1, 0, 1, 0, 1, 1], "scores": [-3.7400431632995605, -1.8505393266677856, 4.897930145263672, -5.906543731689453, -2.325284004211426, -6.046238899230957, -1.645206093788147, 0.9068860411643982], "chosen_index": 2}
{"problem_id": "Artin|exercise_11_2_13", "nl_statement": "If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.", "candidates": ["theorem dummy {a b : ‚Ñ§} (h : a ‚à£ b) : a ‚à£ b := sorry", "theorem dummy (a b : ‚Ñ§) (ha : a ‚à£ b) : a ‚à£ (b : ‚Ñ§) := sorry", "theorem dummy {a b : ‚Ñ§} (hab : a ‚à£ b) : a ‚à£ b := sorry", "theorem dummy (a b : ‚Ñ§) (hab : a ‚à£ b) : a ‚à£ b := sorry", "theorem dummy {a b : ‚Ñ§} (h : a ‚à£ b) : a ‚à£ b' := sorry"], "labels": [0, 0, 0, 0, 0], "scores": [-5.8182053565979, -5.651739597320557, -5.767950057983398, -5.6574482917785645, -5.870057106018066], "chosen_index": 1}
{"problem_id": "Herstein|exercise_5_6_14", "nl_statement": "If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.", "candidates": ["theorem dummy {F : Type*} [Field F] {p n : ‚Ñï} [hf : CharP F p] : ‚àÄ m : ‚Ñï, m = p^n ‚Üí ‚àÄ x y : F, x^m = x ‚Üí y^m = y ‚Üí x = y := sorry", "theorem dummy {F : Type*} [Field F] (p : ‚Ñï) [hp : Fact (Nat.Prime p)] [CharP F p] (n : ‚Ñï) : (‚àÉ (x : F), x ^ (p ^ n) = x) ‚Üí (‚àÄ x y : F, x ‚â† y ‚Üí x ^ (p ^ n) ‚â† y ^ (p ^ n)) := sorry", "theorem dummy {F : Type*} [Field F] (p : ‚Ñï) [hp : Fact p.Prime] (m : ‚Ñï) (hpm : p^n = m) (z : F) : z ^ m - z = 0 ‚Üî z = 0 ‚à® z ^ p = z := sorry", "theorem dummy {F : Type*} [Field F] (p : ‚Ñï) [hp : Fact (Nat.Prime p)] [CharP F p] (n : ‚Ñï) : ‚àÄ x y : F, (x ^ (p ^ n) = x) ‚Üí (y ^ (p ^ n) = y) ‚Üí x = y ‚Üí x = y := sorry", "theorem dummy {F : Type*} [Field F] [CharP F p] (m : ‚Ñï) (hn : m = p ^ n) : ‚àÄ (x : F), x ^ m ‚â† x ‚Üí x ‚â† (x ^ p) ^ n := sorry", "theorem dummy {F : Type*} [Field F] (hp : CharP F p) (m : ‚Ñï) (hn : m = p ^ n) : ‚àÄ (x : F), x ‚â† 1 ‚Üí x ^ m ‚â† x ‚Üí x ‚àà roots (X - X) ‚Üí true := sorry", "theorem dummy {F : Type*} [Field F] [CharP F p] {m : ‚Ñï} (hmn : m = p ^ n) : ‚àÄ (x : F), x ‚â† 1 ‚Üí ‚àÉ! y, y ^ m = x ‚àß y ‚â† 1 := sorry", "theorem dummy {F : Type*} [Field F] [CharP F p] {m : ‚Ñï} (hm : m = p ^ n) : ‚àÄ (x : F), x ‚â† 1 ‚Üí x ^ m ‚â† x ‚Üí x ^ m ‚â† 1 ‚Üí ‚àÉ y : F, (y ^ m - y = 0) ‚àß y ‚â† x := sorry", "theorem dummy (F : Type*) [Field F] {p : ‚Ñï} [CharP F p] (hp : p ‚â† 0) (m : ‚Ñï) : Polynomial.Splits (RingHom.id F) (Polynomial.X ^ p ^ m - Polynomial.X) := sorry", "theorem dummy (F : Type*) [Field F] (p : ‚Ñï) [hF : CharP F p] (m : ‚Ñï) (h : Fact (p ‚â† 0) ‚àß m = p ^ n) : (‚àÉ x : F, x ^ m - x = 0) ‚Üí (‚àÄ (x y : F), x ^ m - x = 0 ‚àß y ^ m - y = 0 ‚Üí x = y) := sorry", "theorem dummy {F : Type*} [Field F] [CharP F p] (m : ‚Ñï) (hpm : m = p ^ n) : ‚àÄ (x : F), x ‚â† 1 ‚Üí x ^ m ‚â† x ‚Üí x ‚â† 0 ‚Üí x ^ m - x ‚â† 0 := sorry", "theorem dummy {F : Type u} [Field F] {m : ‚Ñï} [hFchar : CharP F p] (hm : p^n = m) (x : F) (hx : x^m = x) : x = 0 := sorry", "theorem dummy (F : Type*) [Field F] [hF : CharP F p] (m : ‚Ñï) (h : m = p^n) : (‚àÄ (x : F), x^m = x ‚Üí x = 0) ‚àß (‚àÄ (x : F), x^(m-1) = 1 ‚Üí x = 1) := sorry", "theorem dummy {F : Type*} [Field F] [hF : CharP F p] (m : ‚Ñï) (h : m = p^n) : (X : Fin m ‚Üí F) -> (‚àÄ i j : Fin m, i ‚â† j -> X i ‚â† X j) := sorry", "theorem dummy {F : Type*} [Field F] {p : ‚Ñï} [CharP F p] (n : ‚Ñï) [Fact (p = 0 ‚à® p = 1 ‚à® p ‚â† 1)] (hp : p = 0 ‚à® p = 1 ‚à® p ‚â† 1) : IsCyclic (Multiplicative (ZMod (p ^ n))) := sorry", "theorem dummy {F : Type*} [Field F] [CharP F p] (n : ‚Ñï) (hpn : p^n ‚â† 0) : ‚àÄ x : F, x ‚â† 1 ‚Üí x^(p^n) ‚â† x := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "scores": [-6.131855010986328, -6.175047874450684, -4.811778545379639, -6.221590042114258, -6.098519325256348, -5.8640289306640625, -5.978110313415527, -5.995177268981934, 5.334630966186523, -5.6570329666137695, -6.055899620056152, 1.6864731311798096, -4.85222053527832, -5.926987648010254, -4.577444553375244, -5.684783935546875], "chosen_index": 8}
{"problem_id": "Munkres|exercise_20_2", "nl_statement": "Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.", "candidates": ["theorem dummy : SecondCountableTopology (EuclideanSpace ‚Ñù (Fin 2)) := sorry", "theorem dummy [TopologicalSpace (‚Ñù √ó ‚Ñù)] : MetrizableSpace (‚Ñù √ó ‚Ñù) := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [SecondCountableTopology X] [PolishSpace X] : MetrizableSpace X := sorry", "theorem dummy : MetrizableSpace (Prod ‚Ñù ‚Ñù) := sorry", "theorem dummy : MetrizableSpace (Prod.{0,0} ‚Ñù ‚Ñù) := sorry", "theorem dummy : MetrizableSpace (Prod.{0, 0} ‚Ñù ‚Ñù) := sorry", "theorem dummy : MetrizableSpace (‚Ñù √ó ‚Ñù) := sorry"], "labels": [0, 0, 0, 0, 0, 0, 0], "scores": [-2.6124486923217773, -5.244612693786621, -5.425281524658203, -5.1962385177612305, -5.0558857917785645, -5.014997959136963, -4.731731414794922], "chosen_index": 0}
{"problem_id": "Herstein|exercise_2_1_26", "nl_statement": "If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.", "candidates": ["theorem dummy {G : Type*} [Group G] [Fintype G] {p : ‚Ñï} {n : ‚Ñï} [hp : Fact (Nat.Prime p)] (hG : Fintype.card G = p ^ n) {k : ‚Ñï} (hk : n < k) : ‚àÉ (m : ‚Ñï), 0 < m ‚àß a ^ m = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] [DecidableEq G] {p z : ‚Ñï} (hp : Nat.Prime p) (hz : Fintype.card G = p ^ z) (n : ‚Ñï) [hzp : Fact (z ‚â§ p)] : ‚àÉ m : ‚Ñï, 0 < m ‚àß a ^ m = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Finite G] (a : G) : ‚àÉ (n : ‚Ñï), a ^ n = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] (a : G) : ‚àÉ n : ‚Ñï, 0 < n ‚àß a ^ n = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Finite G] (a : G) : ‚àÉ n : ‚Ñï, n ‚â† 0 ‚àß a ^ n = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Finite G] (a : G) : ‚àÉ n : ‚Ñï, a ^ n = 1 := sorry", "theorem dummy [Group G] [Finite G] (a : G) : ‚àÉ n : ‚Ñï, n > 0 ‚àß a ^ n = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] (a : G) : ‚àÉ n > 0, a ^ n = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Finite G] {a : G} : ‚àÉ (n : ‚Ñï), a ^ n = 1 := sorry", "theorem dummy (G : Type*) [Group G] [Finite G] (a : G) : ‚àÉ (n : ‚Ñï), a ^ n = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] (a : G) : ‚àÉ n : ‚Ñï, a ^ n = 1 := sorry"], "labels": [0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], "scores": [-5.845744609832764, -5.770956993103027, -5.638648986816406, 6.300121784210205, 5.602105140686035, -5.161746025085449, -0.36623769998550415, 5.158632755279541, -5.579588413238525, -5.741363525390625, -3.9358835220336914], "chosen_index": 3}
{"problem_id": "Rudin|exercise_2_29", "nl_statement": "Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.", "candidates": ["theorem dummy {Œ± : Type*} [TopologicalSpace Œ±] (s : Set Œ±) (h : IsOpen s) : ‚àÉ t : Set (Set Œ±), t.Countable ‚àß s = ‚ãÉ‚ÇÄ t ‚àß ‚àÄ x ‚àà t, ‚àÄ y ‚àà t, x ‚â† y ‚Üí Disjoint x y := sorry", "theorem dummy (s : Set ‚Ñù) (hs : IsOpen s) : s = ‚ãÉ (x ‚àà s) (y ‚àà s), Set.Ioo x y := sorry", "theorem dummy [TopologicalSpace ‚Ñù] : ‚àÄ (s : Set ‚Ñù), IsOpen s ‚Üí ‚àÉ (Œπ : Type) (f : Œπ ‚Üí Set ‚Ñù), Countable Œπ ‚àß (‚àÄ i : Œπ, IsOpen (f i)) ‚àß (‚àÄ x ‚àà s, ‚àÉ i, x ‚àà f i) ‚àß (‚àÄ i j : Œπ, Disjoint (f i) (f j)) ‚àß s = ‚ãÉ i, f i := sorry", "theorem dummy (U : Set ‚Ñù) (hU : IsOpen U) : ‚àÉ (S : Set (Set ‚Ñù)), (‚àÄ s ‚àà S, ‚àÉ a b : ‚Ñù, s = Set.Ioo a b ‚àß a < b) ‚àß (U = ‚ãÉ‚ÇÄ S) ‚àß (Countable S) ‚àß (Pairwise (Disjoint on S)) := sorry", "theorem dummy (U : Set ‚Ñù) (hU : IsOpen U) : ‚àÉ (I : Set (Set ‚Ñù)), (‚àÄ i ‚àà I, ‚àÉ a b : ‚Ñù, i = Set.Ioo a b) ‚àß Countable I ‚àß U = ‚ãÉ‚ÇÄ I := sorry", "theorem dummy (U : Set ‚Ñù) (hU : IsOpen U) : ‚àÉ (S : Set (Set ‚Ñù)), (‚àÄ s ‚àà S, ‚àÉ a b : ‚Ñù, s = Set.Ioo a b) ‚àß Pairwise (Disjoint on S) ‚àß Countable S ‚àß U = ‚ãÉ‚ÇÄ S := sorry", "theorem dummy {s : Set ‚Ñù} (hs : IsOpen s) : ‚àÉ t : Set (Set ‚Ñù), t.Countable ‚àß s = ‚ãÉ‚ÇÄ t ‚àß ‚àÄ a b c d, a ‚àà t ‚Üí b ‚àà t ‚Üí c ‚àà t ‚Üí d ‚àà t ‚Üí a ‚â† b ‚Üí a ‚â† c ‚Üí a ‚â† d ‚Üí b ‚â† c ‚Üí b ‚â† d ‚Üí c ‚â† d ‚Üí (a ‚à© b).Nonempty ‚Üí (c ‚à© d).Nonempty ‚Üí a ‚à© b ‚à© c ‚à© d = ‚àÖ := sorry", "theorem dummy {s : Set ‚Ñù} (hs : IsOpen s) : ‚àÉ t : Set (Set ‚Ñù), t.Countable ‚àß s = ‚ãÉ‚ÇÄ t ‚àß ‚àÄ a b, a ‚àà t ‚Üí b ‚àà t ‚Üí a ‚â† b ‚Üí Disjoint a b := sorry"], "labels": [0, 0, 0, 1, 0, 1, 0, 0], "scores": [0.5252184271812439, -6.038108825683594, -1.7878179550170898, 3.1981775760650635, -3.373544454574585, 5.198321342468262, -5.992828369140625, -5.626460075378418], "chosen_index": 5}
{"problem_id": "Munkres|exercise_33_7", "nl_statement": "Show that every locally compact Hausdorff space is completely regular.", "candidates": ["theorem dummy {X : Type*} [TopologicalSpace X] [LocallyCompactSpace X] [T2Space X] : T3Space X := sorry", "theorem dummy [TopologicalSpace X] [T2Space X] (h : ‚àÄ x : X, ‚àÉ s : Set X, IsCompact s ‚àß IsOpen s ‚àß x ‚àà s) : LocallyCompactSpace X := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [LocallyCompactSpace X] [T2Space X] : RegularSpace X := sorry", "theorem dummy [TopologicalSpace Œ±] [H : LocallyCompactSpace Œ±] [h : T2Space Œ±] : RegularSpace Œ± := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] (hLC : LocallyCompactSpace X) (hH : T2Space X) : CompletelyRegularSpace X := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] [LocallyCompactSpace X] [T2Space X] : CompletelyRegularSpace X := sorry", "theorem dummy {X : Type*} [TopologicalSpace X] (hX : LocallyCompactSpace X) (hX' : T2Space X) : CompletelyRegularSpace X := sorry"], "labels": [0, 0, 0, 0, 1, 1, 1], "scores": [2.638699531555176, -5.859832763671875, 5.238192558288574, 4.883862495422363, 7.89475154876709, 7.680753707885742, 7.775476455688477], "chosen_index": 4}
{"problem_id": "Munkres|exercise_28_6", "nl_statement": "Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.", "candidates": ["theorem dummy {X : Type*} [MetricSpace X] [CompactSpace X] (f : X ‚Üí X) (hf : ‚àÄ x y : X, dist (f x) (f y) = dist x y) : Function.Bijective f ‚àß Isometry f ‚àß Continuous f := sorry", "theorem dummy {X : Type u} [MetricSpace X] (f : X ‚Üí X) (hf : ‚àÄ x y : X, dist (f x) (f y) = dist x y) (hX : CompactSpace X) : Function.Bijective f := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompactSpace X] (f : X ‚Üí X) (hf : ‚àÄ x y : X, dist (f x) (f y) = dist x y) : Function.Bijective f := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompactSpace X] {f : X ‚Üí X} (hf : Isometry f) : Function.Bijective f := sorry", "theorem dummy {X : Type u} [MetricSpace X] [CompactSpace X] {f : X ‚Üí X} (h : ‚àÄ x y : X, dist (f x) (f y) = dist x y) : Isometry f := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompactSpace X] (f : X ‚Üí X) (hf : ‚àÄ x y : X, dist (f x) (f y) = dist x y) : Function.Bijective f ‚àß ‚àÉ h : Homeomorph X X, h.toFun = f := sorry", "theorem dummy {X : Type*} [MetricSpace X] [CompactSpace X] (f : X ‚Üí X) (hf : ‚àÄ x y : X, dist (f x) (f y) = dist x y) : Isometry f ‚àß Function.Bijective f := sorry", "theorem dummy {X : Type u} [MetricSpace X] [CompactSpace X]: ‚àÄ (f : X ‚Üí X), ‚àÄ (x y : X), dist (f x) (f y) = dist x y ‚Üí Isometry f := sorry"], "labels": [0, 0, 0, 0, 0, 1, 0, 0], "scores": [-1.3679349422454834, -3.8698861598968506, -4.288513660430908, -4.346931457519531, -5.629214286804199, 2.790926456451416, -1.917296051979065, -5.806188583374023], "chosen_index": 5}
{"problem_id": "Munkres|exercise_31_3", "nl_statement": "Show that every order topology is regular.", "candidates": ["theorem dummy {Œ± : Type u} [PartialOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] : RegularSpace Œ± := sorry", "theorem dummy {Œ± : Type u} [TopologicalSpace Œ±] [PartialOrder Œ±] [OrderTopology Œ±] : RegularSpace Œ± := sorry", "theorem dummy {S : Type*} [LinearOrder S] [TopologicalSpace S] : ‚àÄ x y : S, x < y ‚Üí ‚àÉ U : Set S, IsOpen U ‚àß x ‚àà U ‚àß y ‚àâ U := sorry", "theorem dummy {X : Type*} [PartialOrder X] [TopologicalSpace X] [OrderTopology X] : ‚àÄ (x : X) (s : Set X), IsOpen s ‚Üí x ‚àà s ‚Üí ‚àÉ (t : Set X), IsOpen t ‚àß x ‚àà t ‚àß Disjoint t s := sorry", "theorem dummy {Œ± : Type u} [PartialOrder Œ±] [t : TopologicalSpace Œ±] [t' : OrderTopology Œ±] : T2Space Œ± := sorry", "theorem dummy {Œ± : Type*} [LinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] : RegularSpace Œ± := sorry", "theorem dummy (X : Type*) [PartialOrder X] [TopologicalSpace X] [OrderTopology X] : RegularSpace X := sorry", "theorem dummy {X : Type*} [Preorder X] [TopologicalSpace X] : RegularSpace X := sorry", "theorem dummy (Œ± : Type*) [PartialOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] : RegularSpace Œ± := sorry", "theorem dummy {Œ± : Type*} [LinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] : T2Space Œ± := sorry"], "labels": [1, 1, 0, 0, 0, 1, 1, 0, 1, 0], "scores": [5.479254722595215, 5.62144136428833, -5.342782020568848, -5.6228156089782715, -4.709163665771484, 4.9578752517700195, 6.7864813804626465, -2.336829423904419, 6.607067108154297, -4.178142547607422], "chosen_index": 6}
{"problem_id": "Herstein|exercise_4_3_1", "nl_statement": "If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.", "candidates": ["theorem dummy {R : Type u} [CommRing R] (a : R) : IsPrime (Ideal.span { a }) := sorry", "theorem dummy [CommRing R] {I : Ideal R} {x : R} (hx : x ‚àà I) : (I : Set R) ‚äÜ span {x} := sorry", "theorem dummy {R : Type*} [CommRing R] (a b : R) : a ‚àà Submodule.span R {b} ‚Üî b ‚àà Submodule.span R {a} := sorry"], "labels": [0, 0, 0], "scores": [-6.17141580581665, -6.202191352844238, -6.1496171951293945], "chosen_index": 2}
{"problem_id": "Herstein|exercise_2_5_43", "nl_statement": "Prove that a group of order 9 must be abelian.", "candidates": ["theorem dummy (G : Type*) [Group G] [Fintype G]: Fintype.card G = 1 ‚à® ‚àÉ p : ‚Ñï, Nat.Prime p ‚àß Fintype.card G = p ‚à® Fintype.card G = p^2 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] (hcard : Fintype.card G = 9) : ‚àÄ g : G, g ^ 2 = 1 ‚à® g ^ 6 = 1 := sorry", "theorem dummy {G : Type*} [Group G] [Fintype G] : Fintype.card G = 9 ‚Üí ‚àÉ (g h : G), g ‚â† h ‚àß g * h = h * g := sorry"], "labels": [0, 0, 0], "scores": [-5.183351516723633, 2.3339335918426514, -5.158924579620361], "chosen_index": 1}
{"problem_id": "Herstein|exercise_2_8_15", "nl_statement": "Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.", "candidates": ["theorem dummy {p q : ‚Ñï} (hp : Nat.Prime p) (hq : Nat.Prime q) (hq_dvd_p : q ‚à£ p - 1) (h : Fin 2 ‚Üí GroupCat.{0}) : Nonempty (h 0 ‚âÖ h 1) := sorry"], "labels": [0], "scores": [-5.4242119789123535], "chosen_index": 0}
{"problem_id": "Axler|exercise_1_7", "nl_statement": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.", "candidates": ["theorem dummy {U : Set (EuclideanSpace ‚Ñù (Fin 2))} : ‚àÉ (u : EuclideanSpace ‚Ñù (Fin 2)) (h : u ‚àà U), ‚àÄ (t : ‚Ñù), t ‚Ä¢ u ‚àà U ‚Üí u ‚àà U ‚àß t = 1 := sorry", "theorem dummy : ‚àÉ (U : Set (EuclideanSpace ‚Ñù (Fin 2))), U.Nonempty ‚àß ‚àÄ (x : EuclideanSpace ‚Ñù (Fin 2)) (c : ‚Ñù), x ‚àà U ‚Üí c ‚Ä¢ x ‚àà U ‚àß c ‚Ä¢ x ‚â† x := sorry"], "labels": [0, 0], "scores": [-6.175534725189209, -4.855380058288574], "chosen_index": 1}
{"problem_id": "Rudin|exercise_3_21", "nl_statement": "If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.", "candidates": ["theorem dummy {X : Type u} [MetricSpace X] {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (h's : Set.Nonempty s) (h't : Set.Nonempty t) : (‚àÉ x ‚àà s, ‚àÉ y ‚àà t, x = y) ‚Üî s = t := sorry", "theorem dummy {X : Type u} [MetricSpace X] [CompleteSpace X] {s : Set X} (hs : IsClosed s) (H : ‚àÄ x ‚àà s, ùìù[s] x ‚â† ‚ä•) : ‚àÉ x ‚àà s, s ‚äÜ closure ({x} : Set X) := sorry"], "labels": [0, 0], "scores": [-5.044279098510742, -2.6415956020355225], "chosen_index": 1}
{"problem_id": "Shakarchi|exercise_2_13", "nl_statement": "Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.", "candidates": ["theorem dummy {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : ‚àÄ z‚ÇÄ : ‚ÑÇ, ‚àÉ n : ‚Ñï, HasDerivAt f (0 : ‚ÑÇ) z‚ÇÄ) : ‚àÉ m : ‚Ñï, ‚àÄ z‚ÇÄ : ‚ÑÇ, (f (m : ‚ÑÇ) - f z‚ÇÄ) = 0 := sorry"], "labels": [0], "scores": [-5.993391036987305], "chosen_index": 0}
